 # 항목 36: 상속받은 비가상 함수를 파생 클래스에서 재정의하는 것은 절대 금물! - 작성자: 서무성

<aside>
🔎

# 이것만은 잊지말자!

- 상속받은 비가상 함수를 재정의하는 일은 절대로 하지 맙시다.
</aside>

---

### 용어설명

<aside>

- 바인딩: 프로그램 소스에 쓰인 각종 내부 요소, 이름, 식별자들에 대해 값 혹은 속성을 확정하는 과정을 일컫는다. → 더 이상 변경할 수 없는 구속 상태가 되는 것
- 정적 바인딩 (Static Binding): 어떤 함수를 호출할지가 컴파일 시점에 결정되는 것. 비가상 함수가 여기에 해당. 컴파일러는 포인터나 참조자의 선언된 타입(정적 타입)만 보고 호출할 함수를 결정합니다. int a = 0 여기서 int와 a가 정적바인딩
- → 프로그램 실행 이전에 값이 확정되는 경우(compile, Linkin 단계) → 컴파일 단계에서 값이 결정되면 실행 시간에 해석할 필요 및 찾을 필요가 없어 성능적으로 효율이 높아짐
- **동적 바인딩 (Dynamic Binding):** 어떤 함수를 호출할지가 **프로그램 실행 시점**에 결정되는 것. 가상 함수가 여기에 해당. 프로그램은 포인터가 실제로 가리키는 객체의 타입(동적 타입)을 보고 호출할 함수를 결정합니다. → 유연성이 올라감
</aside>

---

### ❗ 파트 요약: 왜 비가상 함수를 재정의하면 안되는가?

---

### 비가상 함수 재정의 예제

```cpp
class B {
	public:
		void mf();
		...
};

```

- B 클래스와 B라는 이름의 클래스로부터 상속에 의해 파생된 D 파생 클래스가 있다고 생각해보자.
- 아래의 코드에서 mf()를 부르게 되면 어떻게 동작할까?

```cpp
D x;

B *pB = &x; //  x에 대한 포인터를 얻어냅니다.
pB->mf();   //  이 포인터를 통해 mf를 호출합니다. 

D *pD = &x; //  x에 대한 포인터를 얻어냅니다.
pD->mf();   //  이 포인터를 통해 mf를 호출합니다.

class D: public B {
	public:
    void mf(); // B::mf를 재정의함
    ...
};

B *pB = &x; // 기본 클래스 포인터로 가리킴
pB->mf();   // B::mf를 호출!

D *pD = &x; // 파생 클래스 포인터로 가리킴
pD->mf();   // D::mf를 호출!
```

- **`pB->mf()`:** `pB`의 **정적 타입**은 `B*`이므로, `mf`가 비가상 함수이기 때문에 컴파일러는 무조건 `B::mf()`를 호출하도록 코드를 만든다.
- **`pD->mf()`:** `pD`의 **정적 타입**은 `D*`이므로, `D::mf()`가 호출된다.
- `pB`는 B 에대한 포인터 타입으로 선언되었기 때문에 `pB`에 입장에서 비가상함수는 B 클래스 내 존재하는 함수라고 인식
- `pB` 가 파생된 객체를 가리켜도 정적 바인딩 원리 때문에 `B::mf()` 호출
- 가상함수
    
    **가상함수**
    
    - 부모 클래스의 함수를 상속 받는 클래스에서 재정의할 것이라 생각하고 정의하는 함수. **`virtual`** 이라는 예약어를 앞에 붙여 사용이 가능하다.
    
    **가상함수를 사용하는 이유**
    
    - 컴파일러는 함수를 호출할 때 매우 복잡한 과정을 거치게 됩니다.
    - 그렇기에 컴파일러는 함수를 호출하는 코드는 컴파일 타임에 고정된 메모리 주소로 변환시킵니다. 이것을 정적바인딩이라고 합니다.
    - 일반 함수의 경우 모두 이러한 정적바인딩을 하게 됩니다. 하지만 일반 함수를 오버 로딩하게 되면 정적바인딩으로 인해 문제가 될 수 있습니다.
    - 가상함수가 아닌 보통의 경우 부모 클래스형 포인터로 멤버 함수를 호출할때, 컴파일러는 정적타입을 보고 이 타입에 맞는 멤버함수를 호출하기 때문입니다.
    
    ```cpp
    #include <iostream>
    using namespace std;
    
    class Parent{
    public:
        void print() {
            cout << "이곳은 Parent입니다." << endl;
        }
    };
    
    class Child : public Parent{
    public:
        void print() {
            cout << "이곳은 Child입니다." << endl;
        }
    };
    
    void main() {
        Parent* p = new Parent;
        Child* c = new Child;
        
        p->print();
        p = c;
        p->print();
    }
    
    // 결과
    // 이곳은 Parent입니다.
    // 이곳은 Parent입니다.
    ```
    
    ```cpp
    #include <iostream>
    using namespace std;
    
    class Parent{
    public:
        virtual void print() { //virtual함수 선언
            cout << "이곳은 Parent입니다." << endl;
        }
    };
    
    class Child : public Parent{
    public:
        virtual void print() {
            cout << "이곳은 Child입니다." << endl;
        }
    };
    
    void main() {
        Parent* p = new Parent;
        Child* c = new Child;
        
        p->print();
        p = c;
        p->print();
    }
    
    // 결과
    // 이곳은 Parent입니다.
    // 이곳은 Child입니다.
    ```
    
    ---
    
    https://coding-factory.tistory.com/699
    

### 이것이 왜 문제인가?

- 동일한 객체에 동일한 함수를 호출했는데, 포인터의 타입에 따라 다른 동작이 일어나는 문제가 발생한다.
- `public` 상속은 "파생 클래스는 기본 클래스의 일종이다(is-a)"라는 관계. 이는 기본 클래스 객체에 적용되는 모든 것이 파생 클래스 객체에도 동일하게 적용되어야 함.  하지만 비가상 함수를 재정의하면 이 원칙이 깨지는 문제가 발생

### 해결방법

**두 가지 명제**

1. B 객체에 해당되는 모든 것들이 D 객체에 그대로 적용된다. is-a 관계 상기시켜볼 것.
2. B에서 파생된 클래스는 mf 함수의 인터페이스와 구현을 모두 물려받는다. 따라서, mf는 B의 비가상 멤버함수이다.
- D클래스는 비가상 멤버 함수를 재정의 해서 사용하고 있으므로, 명제에 어긋남
- `mf()`를 재정의 하려면 가상함수로 구현을 하거나 `public` 상속을 받지 않으면 해결이 가능함

---

### 그냥 상속 받아서 함수 다르게 할거면 가상함수 쓰라는 얘기인듯
