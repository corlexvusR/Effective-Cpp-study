# 항목 44: 매개변수에 독립적인 코드는 템플릿으로부터 분리시키자 - 작성자: 고형주

<aside>

# 🔎 이것만은 잊지 말자!

- 템플릿을 사용하면 비슷비슷한 클래스와 함수가 여러 벌 만들어집니다. 따라서 템플릿 매개변수에 종속되지 않은 템플릿 코드는 비대화의 원인이 됩니다.
- 비타입 템플릿 매개변수로 생기는 코드 비대화의 경우, 템플릿 매개변수를 함수 매개변수 혹은 클래스 데이터 멤버로 대체함으로써 비대화를 종종 없앨 수 있습니다.
- 타입 매개변수로 생기는 코드 비대화의 경우, 동일한 이진 표현구조를 가지고 인스턴스화되는 타입들이 한 가지 함수 구현을 공유하게 만듦으로써 비대화를 감소시킬 수 있습니다.
</aside>

# 배경 지식

<aside>

### 코드 비대화

템플릿 인스턴스화로 인해, 거의 동일한 코드가 여러 번 생성되어 실행 파일 크기가 불필요하게 커지는 현상

### 공통성 및 가변성 분석

코드에서 공통 부분과 가변 부분을 식별하여 중복을 제거하는 설계 기법

### 비타입 템플릿 매개변수

타입이 아닌 값을 템플릿 매개변수로 받는 것 (예: `template<typename T, std::size_t N>`)

</aside>

---

<aside>

# 📌 템플릿과 코드 중복의 차이

</aside>

## 템플릿의 장점

템플릿은 코딩 시간 절약, 코드 중복 회피를 하게 해주는 효율적인 문법이다.

```cpp
// 템플릿 없이 20개 클래스 작성 (각 15개 멤버 함수) -> 300개 함수를 일일이 타이핑해야 함

// 템플릿 사용
template<typename T>
class MyClass {
    // 멤버 함수 15개 작성
};
// 컴파일러가 필요한 20개 클래스와 300개 함수를 자동 생성
```

## 코드 중복의 차이점

| 구분          | 일반 코드                 | 템플릿 코드                   |
| ------------- | ------------------------- | ----------------------------- |
| **중복 발생** | 명시적 (소스 코드에 보임) | 암시적 (컴파일러가 생성)      |
| **발견 방법** | 눈으로 직접 확인 가능     | 인스턴스화 패턴을 분석해야 함 |
| **해결 시점** | 코딩 단계                 | 설계 단계부터 고려 필요       |

### 일반 코드에서의 중복 제거

```cpp
// [중복 있음]
void processA() {
    // 공통 로직
    // A 고유 로직
}

void processB() {
    // 공통 로직 (processA와 동일한 로직)
    // B 고유 로직
}

// [중복 제거]
void commonLogic() { /* 공통 로직 */ }

void processA() {
    commonLogic();
    // A 고유 로직
}

void processB() {
    commonLogic();
    // B 고유 로직
}
```

### 템플릿에서의 중복

템플릿 코드에서는 **소스 코드에 템플릿이 하나만 있어도**, 여러 번 인스턴스화될 때 **암시적으로 코드 중복이 발생**한다.
아무 생각 없이 템플릿을 사용하면 템플릿의 적인 **코드 비대화(code bloat)**가 초래될 수 있다.

---

<aside>

# 📌 문제 상황: 정방행렬 템플릿의 코드 비대화

</aside>

고정 크기의 정방행렬을 나타내는 클래스 템플릿을 만들어보자. 다른 기능들도 있지만 특히 이 클래스 템플릿은 역행렬 만들기 연산을 지원한다.

## 첫 번째 시도: 비타입 매개변수 사용

```cpp
// T 타입의 객체를 원소로 하는 n행 n열의 행렬을 나타내는 템플릿.
// size_t 매개변수에 대한 이야기는 이후에 확인한다.
template<typename T, std::size_t n>
class SquareMatrix {
public:
	...

	// 주어진 행렬을 그 저장공간에서 역행렬로 만든다.
	void invert();
};
```

이 템플릿은 `T`라는 타입 매개변수도 받지만, `size_t` 타입의 비타입 매개변수(non-type parameter)인 `n`도 받도록 되어 있다. 비타입 매개변수는 타입 매개변수보다는 덜 흔하지만, C++에서 인정되는 매개변수이다.

### 사용 예제

```cpp
SquareMatrix<double, 5> sm1;
// SquareMatrix<double, 5>::invert를 호출한다.
sm1.invert();

SquareMatrix<double, 10> sm2;
// SquareMatrix<double, 10>::invert를 호출한다.
sm2.invert();
```

## 문제 발생: 코드 비대화

### 코드 생성 분석

```cpp
// [컴파일러가 생성하는 코드]

// 5×5 행렬용 invert
void SquareMatrix<double, 5>::invert() {
    // 5×5 역행렬 계산 로직
}

// 10×10 행렬용 invert
void SquareMatrix<double, 10>::invert() {
    // 10×10 역행렬 계산 로직 (위와 거의 동일!)
}
```

### 문제점

- **행렬 크기(5, 10)만 다르고 나머지 로직은 완전히 동일 → 코드 비대화**
- 각 크기마다 별도의 invert 함수가 생성됨
- 크기가 다른 행렬을 사용할 때마다 동일한 코드가 반복 생성

---

<aside>

# 📌 해결 방법 1: 크기 독립적 기본 클래스

</aside>

## 기본 아이디어

- **공통 부분**: 역행렬 계산 로직 (크기만 다름)
- **가변 부분**: 행렬 크기 (5, 10, ...)
- **해결 방법**: 크기를 매개변수로 받는 함수를 기본 클래스에 배치

**행렬 크기에 의존하지 않는 코드를 기본 클래스로 분리**한다.

## 첫 번째 구현

```cpp
// 정방행렬에 대해 쓸 수 있는 크기에 독립적인 기본 클래스
// [기본 클래스] - 크기 독립적
template<typename T>
class SquardMatrixBase {
protected:
	...
	// 주어진 크기의 행렬을 역행렬로 만든다.
	void invert(std::size_t matrixsize);
	...
};

// [파생 클래스] - 크기 종속적
template<typename T, std::size_t n>
class SquareMatrix: private SquareMatrixBase<T> {
private:
	// 기본 클래스의 invert가 가려지는 것을 막기 위한 문장이다. (이름 가리기 방지)
	using SquareMatrixBase<T>::invert;

public:
	...
	// 인라인으로 invert의 기본 클래스 버전 호출
	// "this->"가 왜 여기에 있는지에 대한 답은 아래에서 설명한다.
	void invert() {this->invert(n);}
};
```

### 개선 사항

| 항목                         | 기존 방식     | 개선된 방식      |
| ---------------------------- | ------------- | ---------------- |
| **invert 함수 개수**         | 크기마다 생성 | 타입마다 1개만   |
| **SquareMatrix<double, 5>**  | 전용 invert   | 공유 invert 호출 |
| **SquareMatrix<double, 10>** | 전용 invert   | 공유 invert 호출 |
| **코드 크기**                | 큼            | 작음             |

### 동작 과정

```cpp
SquareMatrix<double, 5> sm1;
sm1.invert();
// 1. SquareMatrix<double, 5>::invert() 호출 (인라인)
// 2. SquareMatrixBase<double>::invert(5) 호출
// 3. 크기 5를 매개변수로 받아 역행렬 계산

SquareMatrix<double, 10> sm2;
sm2.invert();
// 1. SquareMatrix<double, 10>::invert() 호출 (인라인)
// 2. SquareMatrixBase<double>::invert(10) 호출 (같은 함수)
// 3. 크기 10을 매개변수로 받아 역행렬 계산
```

`SquareMatrixBase::invert` 함수는 파생 클래스에서 코드 복제를 피할 목적으로만 마련한 장치이기 때문에, `public` 멤버가 아니라 `protected` 멤버로 되어 있다는 점도 알아두어야 한다. 이 함수의 호출에 드는 추가 비용은 하나도 없어야 한다. 기본 클래스의 `invert` 함수를 호출하도록 구현된 파생 클래스의 `invert` 함수가 바로 인라인 함수이기 때문이다. (이 경우에는 암시적 인라인 함수이다.)

### 설계 특징

1. private 상속 사용

   ```cpp
   class SquareMatrix : private SquareMatrixBase<T>
   ```

   - 기본 클래스는 순전히 구현을 돕기 위한 용도
   - is-a 관계가 아님을 명시

1. `this→` 표기

   ```cpp
   void invert() { this->invert(n); }
   ```

   - 템플릿화된 기본 클래스의 멤버 이름이 가려지는 것을 방지
   - using 선언이 있어서 사실 불필요하지만, 명시적으로 표현함

## 문제: 데이터 접근

기본 클래스의 `invert` 함수가 행렬 데이터에 어떻게 접근할까?

```cpp
template<typename T>
class SquareMatrixBase {
protected:
    void invert(std::size_t matrixSize) {
        // [문제] 행렬 데이터가 어디 있지?
        // 데이터를 저장하는 것은 파생 클래스인데...
    }
};

```

---

<aside>

# 📌 해결 방법 2: 기본 클래스에 데이터 포인터 저장

</aside>

## 개선된 설계

기본 클래스(SquareMatrixBase)가 **데이터 포인터와 크기를 저장**하도록 한다.

```cpp
template<typename T>
class SquareMatrixBase {
protected:
	// 행렬 크기와 행렬 값에 대한 데이터 포인터를 저장
	SquareMatrixBase(std::size_t n, T *pMem): size(n), pData(pMem) {}

	// pData에 다시 대입
	void setDataPtr(T *ptr) { pData = ptr; }
	...

private:
	// 행렬의 크기
	std::size_t size;

	// 행렬 값에 대한 포인터
	T *pData;
};
```

이렇게 설계해두면, (행렬 값을 담을) 메모리 할당 방법의 결정 권한이 파생 클래스 쪽으로 넘어가게 된다. 예를 들어 파생 클래스를 만드는 사람에 따라, 행렬 데이터를 `SquareMatrix` 객체 안에 데이터 멤버로 직접 넣은 것으로 결정할 수도 있다.

---

<aside>

# 📌 메모리 할당 전략

</aside>

데이터를 어디에 저장할지는 파생 클래스가 결정한다.

## 전략 1: 스택 할당 (배열 사용)

```cpp
template<typename T, std::size_t n>
class SquareMatrix: private SquareMatrixBase<T> {
public:
	// 행렬 크기(n) 및 데이터 포인터를 기본 클래스로 올려보낸다.
	SquareMatrix() : SquareMatrixBase<T>(n, data) {}
	...

private:
	// 스택에 직접 저장
	T data[n*n];
};
```

### **장점**

- 동적 메모리 할당 불필요

### **단점**

- 객체 크기가 커짐

이 방법이 마음에 들지 않다면 각 행렬의 데이터를 힙에 둘 수도 있다.

## 전략 2: 힙 할당 (스마트 포인터 사용)

```cpp
template<typename T, std::size_t n>
class SquareMatrix: private SquareMatrixBase<T> {
public:
	// 기본 클래스의 포인터를 null로 설정하고, 행렬 값의 메모리를 할당하고,
	// 파생 클래스의 포인터에 그 메모리를 물려 놓은 후,
	// 이 포인터의 사본을 기본 클래스로 올려보낸다.
	SquareMatrix() : SquareMatrixBase<T>(n, 0),
	pData(new T[n * n])
	// 포인터 설정
	{ this->setDataPtr(pData.get()); }
	...

private:
	// 힙에 동적 할당
	boost::scoped_array<T> pData;
};
```

### **장점**

- 객체 크기가 작음 (포인터만)
- 큰 행렬도 안전함

### **단점**

- 동적 할당 비용
- 메모리 관리 필요

## 전략 비교

| 특성            | 스택 할당            | 힙 할당            |
| --------------- | -------------------- | ------------------ |
| **객체 크기**   | 크다 (n×n×sizeof(T)) | 작다 (포인터 크기) |
| **할당 속도**   | 빠름                 | 느림               |
| **큰 행렬**     | 위험                 | 안전               |
| **메모리 관리** | 자동                 | 필요               |

---

<aside>

# 📌 성능 트레이드오프

</aside>

위 방법은 성능 트레이드오프가 존재한다.

행렬 크기가 미리 녹아든 상태로 별도의 버전이 만들어지는 `invert`, 그리고 행렬 크기가 함수 매개변수로 넘겨지거나 객체에 저장된 형태로 다른 파생 클래스들이 공유하는 버전의 `invert` 함수, 이 둘을 비교해보면 전자가 후자보다 더 좋은 코드를 생성할 가능성이 높다.

## 두 접근 방식 비교

### 크기별 고정 버전 (원래 방식)

```cpp
template<typename T, std::size_t n>
class SquareMatrix {
    void invert() {
        // n이 컴파일 타입 상수
        // 각 크기마다 별도 함수
    }
};
```

### 크기 독립적 버전 (개선된 방식)

```cpp
template<typename T>
class SquareMatrixBase {
    void invert(std::size_t size) {
        // size가 런타임 매개변수
        // 모든 크기가 하나의 함수 공유
    }
};
```

예를 들어 크기별 고정 버전(전자)의 경우, 행렬 크기가 컴파일 시점에 투입되는 상수이기 때문에 상수 전파(constant propagation) 등의 최적화가 적용하기에 좋다. 생성되는 기계 명령어에 대해 이 크기 값이 즉치 피연산자(immediate operand)로 바로 넣어지는 것도 이런 종류의 최적화 중 하나이다. 이런 혜택은 크기 독립형 버전(후자)에서는 얻을 수 없다.

### 두 방식의 비교

| 측면                   | 크기별 고정 버전        | 크기 독립적 버전    |
| ---------------------- | ----------------------- | ------------------- |
| **코드 크기**          | 크다 (각 크기마다 생성) | 작다 (한 벌만 생성) |
| **실행 파일**          | 큼                      | 작음                |
| **컴파일 타임 최적화** | 우수 (상수 전파 가능)   | 제한적              |
| **즉치 피연산자**      | 사용 가능               | 불가능              |
| **작업 세트 크기**     | 클 수 있음              | 작음                |
| **명령어 캐시 효율**   | 낮을 수 있음            | 높을 수 있음        |
| **참조 지역성**        | 낮을 수 있음            | 높음                |

## 성능 역전 가능성

크기 독립적 버전이 오히려 더 빠를 수 있는 이유

1. **작업 세트 감소** → 더 많은 코드가 캐시에 유지됨
2. **참조 지역성 향상** → 페이지 폴트 감소
3. **명령어 캐시 효율** → 같은 함수를 재사용

어떤 효과가 우선할지 정확한 판단을 위해서는, 쓰고 있는 플랫폼 및 대표적인 데이터 집합에 대해 직접 두 방법을 전부 적용해보고 그 결과를 관찰하는 수 밖에 없다. (벤치마크)

---

<aside>

# 📌 객체 크기 문제

</aside>

효율에 대해 생각해볼 문제가 있다. 바로 객체의 크기이다. `invert` 비슷한 크기 독립형 버전의 함수를 기본 클래스 쪽으로 옮겨 놓다 보면, 각 객체의 전체 크기 때문에 당황스러울 수 있다.

## 포인터 오버헤드

기본 클래스에 데이터 포인터를 저장하면, 파생 클래스의 모든 객체가 포인터를 가지게 된다.

```cpp
template<typename T>
class SquareMatrixBase {
private:
    std::size_t size;   // 포인터 크기 (보통 4~8바이트)
    T *pData;           // 포인터 크기
};

template<typename T, std::size_t n>
class SquareMatrix : private SquareMatrixBase<T> {
private:
    T data[n * n];  // 파생 클래스가 이미 데이터를 가지고 있는데
                     // 포인터까지 추가로 저장하게 된다.
};
```

### 메모리 낭비 분석

```cpp
sizeof(SquareMatrix<double, 5>)

  // size + pData                    // 실제 데이터
= sizeof(SquareMatrixBase<double>) + sizeof(double) * 25

= 16바이트 (포인터 오버헤드) + 200바이트
```

`SquareMatrix` 객체는 파생 클래스 자체에 이미 이 데이터에 접근할 수 있는 수단이 있는데도, 메모리에 생길 때마다 `SquareMatrixBase` 클래스에 들어 있는 데이터를 가리키는 포인터를 하나씩 가지고 있다.

이 때문에 `SquareMatrix` 객체 하나의 크기는 최소한 포인터 하나 크기 만큼 낭비한다.

### 이러한 문제의 해결에 대한 복잡성

포인터 없이 설계하려면,

- **캡슐화 효과 저하**: protected 데이터 멤버 직접 접근
- **자원 관리 복잡**: 누가 메모리를 해제할지 불명확
- **설계 복잡도 증가**: 스택/힙 할당 전략마다 다른 처리

### **결론**

어느 정도의 코드 중복은 허용하는 것이 현실적일 수 있다

---

<aside>

# 📌 타입 매개변수와 코드 비대화

</aside>

이번 항목에서는 비타입 템플릿 매개변수로 인한 코드 비대화만을 다루었다. 그러나 비타입 매개변수만이 코드 비대화의 원인은 아니다. **타입 매개변수도 비대화를 일으킬 수 있다.**

## 이진 표현구조가 동일한 타입들

### `int`와 `long`

```cpp
// 많은 플랫폼에서 int와 long은 이진 표현 구조가 동일 (32비트)
vector<int> vi;
vector<long> vl;

// [컴파일러가 생성하는 코드]
// 두 벡터의 멤버 함수가 거의 동일한 기계어 코드를 생성
void vector<int>::push_back(int value) { ... }
void vector<long>::push_back(long value) { ... }  // 거의 동일
```

`int` 및 `long`에 대해 인스턴스화되는 템플릿들은 ‘어떤 환경’에서는 코드 비대화를 일으킬 수 있다고 말이다.

### 포인터 타입들

```cpp
// 모든 포인터는 같은 크기와 표현구조
list<int*> li;
list<const int*> lci;
list<SquareMatrix<long, 3>*> lsm;

// [컴파일러가 생성하는 코드]
// 포인터 크기가 같으므로 생성되는 코드가 거의 동일
```

대부분의 플랫폼에서 포인터 타입은 똑같은 이진 표현구조를 갖고 있기 때문에, 포인터 타입을 매개변수로 취하는 동일 계열의 템플릿들은 이진 수준에서만 보면 멤버 함수 집합을 한 벌만 써도 되어야 한다.

## 해결 방법: void\* 기반 구현

```cpp
// [타입 독립적 기본 구현]
template<typename T>
class VectorBase {
protected:
    void push_back_impl(void* elem) {
        // void* 포인터로 동작하는 구현
        // 모든 포인터 타입이 공유
    }
};

// [타입 안전 래퍼]
template<typename T>
class Vector : private VectorBase<T> {
public:
    void push_back(T* elem) {
        // 타입 검사 후 void*로 변환하여 호출
        this->push_back_impl(static_cast<void*>(elem));
    }
};
```

타입 제약이 엄격한 포인터(즉, `T*` 포인터)를 써서 동작하는 멤버 함수를 구현할 때는 하단에서 타입미정(untyped) 포인터(즉, `void*` 포인터)로 동작하는 버전을 호출하는 식으로 만든다는 뜻이다.

### 실제 사례

C++ 표준 라이브러리의 일부 구현이 이 방법을 사용한다:

- `vector`, `deque`, `list` 등의 컨테이너
- 포인터 타입에 대해 타입미정(untyped) 구현을 공유
- 타입 안전성은 상위 레벨에서 보장

---

<aside>

# 📌 결론

</aside>

## 원칙

1. **공통성 분석**: 템플릿 매개변수에 독립적인 코드를 식별
2. **계층화**: 공통 부분은 기본 클래스로, 가변 부분은 파생 클래스로
3. **매개변수화**: 템플릿 매개변수를 함수 매개변수나 데이터 멤버로 전환

## 비타입 매개변수 대응

```cpp
// Before: 코드 비대화
template<typename T, std::size_t N>
class Container {
    void process() { /* N 사용 */ }
};

// After: 크기 독립적
template<typename T>
class ContainerBase {
    void process(std::size_t n) { /* n 사용 */ }
};

template<typename T, std::size_t N>
class Container : private ContainerBase<T> {
    void process() { this->process(N); }
};
```

## 타입 매개변수 대응

```cpp
// Before: 포인터마다 별도 코드
template<typename T>
class SmartPtr {
    void reset(T* ptr) { /* T* 사용 */ }
};

// After: void* 기반 공통 구현
class SmartPtrBase {
    void reset_impl(void* ptr) { /* void* 사용 */ }
};

template<typename T>
class SmartPtr : private SmartPtrBase {
    void reset(T* ptr) {
        reset_impl(static_cast<void*>(ptr));
    }
};
```

---
