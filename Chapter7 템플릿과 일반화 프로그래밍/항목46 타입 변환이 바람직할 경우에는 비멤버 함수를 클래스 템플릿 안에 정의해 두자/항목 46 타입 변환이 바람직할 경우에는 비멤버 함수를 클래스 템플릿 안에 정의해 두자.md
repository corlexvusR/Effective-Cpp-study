# 항목 46: 타입 변환이 바람직할 경우에는 비멤버 함수를 클래스 템플릿 안에 정의해 두자 - 작성자: 고형주

<aside>

# 🔎 이것만은 잊지 말자!

- 모든 매개변수에 대해 암시적 타입 변환을 지원하는 템플릿과 관계가 있는 함수를 제공하는 클래스 템플릿을 만들려고 한다면, 이런 함수는 클래스 템플릿 안에 프렌드 함수로서 정의합시다.
</aside>

---

<aside>

# 📌 문제 상황: 템플릿 버전의 Rational 클래스

</aside>

항목 24에서 비템플릿 `Rational` 클래스에서 모든 매개변수에 대해 암시적 타입 변환이 가능하도록 `operator*`를 비멤버 함수로 만드는 방법을 배웠다.

이제는 `Rational`을 템플릿으로 만들어본다.

## 첫 번째 시도: 비멤버 함수 템플릿

```cpp
template<typename T>
class Rational {
public:
	// 매개변수가 참조자로 전달됨
	Rational (const T& numerator = 0, const  T& denominator = 1);

	// 반환 값 전달은 값에 의한 전달
	const T numerator() const;
	const T denominator() const;
	...
};

template<typename T>
const Rational<T> operator& (const Rational<T>& lhs, const Rational<T>& rhs)
{ ... }
```

## 문제 발생

혼합형(mixed-mode) 수치 연산은 여전히 필요하다. 다음의 코드가 컴파일 되어야 한다.

```cpp
Rational<int> onehalf(1, 2);

// [에러] 컴파일 불가
Rational<int> result = onehalf * 2;
```

## 컴파일이 안되는 이유

### 컴파일러 관점

1. `oneHalf * 2`를 보고 `operator*` 함수를 찾으려 함
2. `operator*`는 템플릿이므로 인스턴스화해야 함
3. 인스턴스화하려면 `T`가 무엇인지 알아야 함
4. `T`를 알아내기 위해, `operator*` 호출 시에 넘겨진 인자의 모든 타입을 확인:
   - 첫 번째 인자: `Rational<int>` → `T`는 `int`로 추론 가능
   - 두 번째 인자: `int` → `T`를 어떻게 추론?

## 문제 사항

- `operator*`의 두 번째 매개변수는 `Rational<T>` 타입
- 넘겨진 인자는 `int` 타입
- 템플릿 인자 추론 과정에서는 **암시적 타입 변환이 고려되지 않음**
- `Rational<int>`에 `int`를 받는 생성자가 있어도 소용없음

## 템플릿 인자 추론의 제약

<aside>

템플릿 인자 추론 → 함수 인스턴스화 → 함수 호출 → 암시적 변환 적용
↑
(여기서 막힘)

</aside>

템플릿 인자 추론(template argument deduction) 과정에서는 암시적 타입 변환이 고려되지 않는다.

암시적 타입 변환은 함수 호출 시 적용되지만, 함수를 호출하려면 먼저 어떤 함수가 있는지 알아야 한다. 그런데 함수를 인스턴스화하려면 `T`를 알아야 하고, `T`를 추론하는 과정에서는 암시적 변환이 고려되지 않는다.

---

<aside>

# 📌 해결 방법: 클래스 템플릿 안에 프렌드 함수 선언

</aside>

이와 같은 상황에서 컴파일러가 템플릿 인자 추론을 할 필요가 없도록 하는 방법이 있다. 클래스 템플릿 안에 프렌드 함수를 넣어두면 함수 템플릿으로서의 성격을 주지 않고 특정한 함수 하나를 나타낼 수 있다는 사실을 이용하는 것이다.

## **아이디어**

- 클래스 템플릿 안에 프렌드 함수를 선언하면 **함수 템플릿이 아닌 특정 함수**가 됨
- 클래스 템플릿은 템플릿 인자 추론에 좌우되지 않음
- `Rational<T>` 클래스가 인스턴스화될 때 `T`가 이미 결정되어 있음
- 따라서 프렌드 함수도 `T`가 결정된 상태로 선언됨

## 두 번째 시도: 프렌드 함수 선언

```cpp
template<typename T>
class Rational {
public:
	...
	// [operator* 함수를 선언]
	// Rational은 Rational<T>의 축약형
	friend const Rational operator* (const Rational& lhs, const Rational& rhs);
};

// [operator* 함수를 정의]
// 클래스 외부에 함수 템플릿 정의
template<typename T>
const Rational<T> operator* (const Rational<T>& lhs, const Rational<T>& rhs)
{ ... }
```

이제 혼합형 `operator*` 호출이 컴파일된다.

### **개선 사항**

- `Rational<int> oneHalf(1, 2);`를 선언하면 `Rational<int>` 클래스가 인스턴스화됨
- 이 과정에서 `Rational<int>` 매개변수를 받는 `operator*` 함수도 자동으로 선언됨
- 이제 `operator*`는 함수 템플릿이 아니라 **선언된 함수**
- 컴파일러는 암시적 변환 함수(`Rational`의 비명시 생성자)를 적용할 수 있음

### 동작 과정

```cpp
Rational<int> oneHalf(1, 2);
// -> Rational<int> 클래스 인스턴스화
// -> friend const Rational<int> operator*(const Rational<int>&, const Rational<int>&); 선언됨

Rational<int> result = oneHalf * 2;
// -> operator*(oneHalf, 2) 호출
// -> 2를 Rational<int>(2)로 암시적 변환
// -> operator*(oneHalf, Rational<int>(2)) 호출
```

## 문제점: 링크 에러

위 코드는 **컴파일은 되지만 링크가 안 된다.**

### **이유**

- `Rational` 안에서 `operator*`를 선언만 했을 뿐, 정의는 하지 않음
- 클래스 외부의 `operator*` 템플릿은 별개의 템플릿
- 프렌드 함수의 정의를 제공하지 않았으므로 링커가 함수를 찾지 못함

---

<aside>

# 📌 최종 해결: 클래스 템플릿 안에 프렌드 함수 정의

</aside>

가장 간단한 해결책은 `operator*` 함수의 본문을 선언부와 함께 클래스 안에 넣는 것이다.

```cpp
template<typename T>
class Rational {
public:
	...
friend const Rational operator* (const Rational& lhs, const Rational& rhs);
{
	return Rational(lhs.numerator() * rhs.numerator(),
									lhs.denominator() * rhs.denominator());
}
};
```

이제 `operator*` 함수의 혼합형 호출 코드는 컴파일, 링크, 실행이 가능하다.

```cpp
Rational<int> oneHalf(1, 2);
Rational<int> result = oneHalf * 2;  // [컴파일, 링크, 실행 모두 성공]
result = 2 * oneHalf;                 // [동작]
```

## 흥미로운 부분

### 프렌드를 사용한 이유

- 프렌드 권한이 필요해서가 아님 (`public` 멤버만 사용)
- 모든 인자에 대해 타입 변환이 가능하도록 비멤버 함수가 필요
- 호출 시 상황에 맞는 함수를 자동으로 인스턴스화하려면 클래스 안에 선언 필요
- 클래스 안에 비멤버 함수를 선언하는 유일한 방법이 **`friend`**

### 정리

<aside>

필요: 모든 매개변수에 암시적 변환 가능
→ 비멤버 함수 필요
→ 템플릿 인자 추론 우회 필요
→ 클래스 안에 선언 필요
→ `friend` 키워드 사용
→ 정의도 함께 제공

</aside>

---

<aside>

# 📌 인라인 문제 해결: 도우미 함수 패턴

</aside>

## **문제 상황**

- 클래스 안에 정의된 함수는 암시적으로 인라인으로 선언됨
- 복잡한 함수라면 인라인이 부적절할 수 있음

## **해결 방법: 프렌드 함수는 도우미만 호출하게 만들기**

```cpp
// Rational 템플릿 선언
template<typename T> class Rational;

// 도우미 함수 템플릿을 선언
template<typename T>
const Rational<T> doMultiply(const Rational<T>& lhs, const Rational<T>& rhs);

template<typename T>
class Rational {
public:
	...
// 프렌드 함수가 도우미 함수를 호출하게 만든다.
friend const Rational operator* (const Rational& lhs, const Rational& rhs);
	{ return doMultiply(lhs, rhs); }
	...
};
```

대다수의 컴파일러에서 템플릿 정의를 헤더 파일에 전부 넣을 것을 사실상 강요되므로, `doMultiFly`도 헤더 파일 안에 정의해 넣어야 한다.

```cpp
// 필요하면, 도우미 함수 템플릿을 헤더 파일 안에 정의
template<typename T>
const Rational<T> doMultiply(const Rational<T>& lhs, const Rational<T>& rhs)
{
	return Rational<T>(lhs.numerator() * rhs.numerator(),
										 lhs.denominator() * rhs.denominator());
}
```

### **동작 방식**

1. `operator*`는 인라인 프렌드 함수 (간단한 호출만 수행)
2. 실제 곱셈 로직은 `doMultiply` 템플릿에 구현
3. `doMultiply`는 혼합형 곱셈을 지원할 필요 없음 (`operator*`가 이미 지원)
4. `operator*`가 매개변수를 `Rational` 객체로 변환 후 `doMultiply` 호출

### **장점**

- 인라인 함수는 최소한으로 유지
- 복잡한 로직은 일반 템플릿 함수에 구현
- 코드 크기 증가 최소화

---

<aside>

# 📌 전체 구조 정리

</aside>

## 완전한 구현 예제

```cpp
// 전방 선언
template<typename T> class Rational;
template<typename T>
const Rational<T> doMultiply(const Rational<T>& lhs, const Rational<T>& rhs);

// 클래스 템플릿
template<typename T>
class Rational {
public:
    Rational(const T& numerator = 0, const T& denominator = 1);
    const T numerator() const;
    const T denominator() const;

    // 프렌드 함수: 인라인, 도우미만 호출
    friend const Rational operator*(const Rational& lhs, const Rational& rhs) {
        return doMultiply(lhs, rhs);
    }
};

// 도우미 함수 템플릿 정의
template<typename T>
const Rational<T> doMultiply(const Rational<T>& lhs, const Rational<T>& rhs)
{
    return Rational<T>(lhs.numerator() * rhs.numerator(),
                       lhs.denominator() * rhs.denominator());
}
```

### 각 부분의 역할

| **구성 요소**          | **역할**            | **특징**                           |
| ---------------------- | ------------------- | ---------------------------------- |
| **프렌드 `operator*`** | 암시적 변환 허용    | 인라인, 간단한 호출만              |
| **도우미 doMultiply**  | 실제 곱셈 로직 구현 | 일반 템플릿 함수                   |
| **클래스 템플릿**      | T 타입 결정         | 인스턴스화 시 프렌드 함수도 선언됨 |

---

<aside>

# 📌 개념 정리

</aside>

### 1. 왜 비멤버 함수인가?

**모든 매개변수에 대해 암시적 변환을 허용하기 위해서**

```cpp
// 멤버 함수 (X)
result = oneHalf.operator*(2);  // 2를 Rational로 변환 가능
result = 2.operator*(oneHalf);  // ❌ int에는 이런 멤버 함수 없음

// 비멤버 함수 (O)
result = operator*(oneHalf, 2);  // 둘 다 Rational로 변환 가능
result = operator*(2, oneHalf);  // 둘 다 Rational로 변환 가능
```

### 2. 왜 클래스 안에 선언하는가?

**템플릿 인자 추론을 우회하기 위해서**

- 함수 템플릿: `T`를 추론해야 함 → 암시적 변환 불가
- 클래스 안의 프렌드: `T`가 이미 결정됨 → 암시적 변환 가능

### 3. 왜 정의도 함께 제공하는가?

**링크 에러를 방지하기 위해서**

- 선언만 하면 정의를 찾지 못해 링크 실패
- 클래스 안에 정의하면 인스턴스화 시 정의도 함께 생성

### 4. 도우미 함수는 왜 필요한가?

**인라인 코드 크기 증가를 방지하기 위해서**

- 프렌드 함수는 자동으로 인라인
- 복잡한 로직은 도우미 템플릿으로 분리

---

<aside>

# 📌 결론

</aside>

## 정리

- **비멤버 함수**가 모든 매개변수에 대한 암시적 변환을 허용함
- **템플릿 인자 추론**은 암시적 변환을 고려하지 않음
- **클래스 템플릿 안의 프렌드 함수**는 템플릿 인자 추론을 우회함
- **클래스 안에 정의**까지 해야 링크 에러를 방지할 수 있음
- **도우미 함수 패턴**으로 인라인 코드 크기를 최소화할 수 있음

---
