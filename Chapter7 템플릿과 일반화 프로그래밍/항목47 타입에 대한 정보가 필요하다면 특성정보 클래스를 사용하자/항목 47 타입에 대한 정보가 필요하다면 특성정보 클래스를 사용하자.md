# 항목 47: 타입에 대한 정보가 필요하다면 특성정보 클래스를 사용하자 - 작성자: 서영은

<aside>

# 🔎 이것만은 잊지말자!

- 특성정보 클래스는 컴파일 도중에 사용할 수 있는 타입 관련 정보를 만들어낸다.
- 특성정보 클래스는 템플릿 및 템플릿 특수 버전을 사용하여 구현한다.
- 함수 오버로딩 기법과 결합하여 특성정보 클래스를 사용하면, 컴파일 타임에 결정되는 타입별 if..else 점검문을 구사할 수 있다.
</aside>

---

# 📌 STL 반복자 5가지

각 반복자가 지원하는 연산에 따라 다섯 개의 범주로 나뉨.

## 입력 반복자(input iterator)

- 입력 파일에 대한 읽기 전용 파일 포인터를 본떠서 만듦.
- 전진만 가능.
- 한 번에 한 칸씩만 이동.
- 자신이 가리키는 위치에서 `읽기`만 가능.
- 읽을 수 있는 횟수가 한 번뿐.
- 단일 패스(one-pass) 알고리즘에만 제대로 쓸 수 있음.
- C++ 표준 라이브러리의 istream_iterator가 대표적인 입력 반복자.

## 출력 반복자(output iterator)

- 출력 파일에 대한 쓰기 전용 파일 포인터를 본떠서 만듦.
- 입력 반복자와 비슷하지만 출력용임.
- 전진만 가능.
- 한 번에 한 칸씩만 이동.
- 자신이 가리키는 위치에서 `쓰기`만 가능.
- 쓸 수 있는 횟수가 한 번뿐.
- 단일 패스(one-pass) 알고리즘에만 제대로 쓸 수 있음.
- ostream_iterator가 대표적.

## 순방향 반복자(forward iterator)

- 입력 반복자와 출력 반복자가 하는 일은 기본적으로 다 할 수 있음.
- 자신이 가리키고 있는 위치에서 읽기와 쓰기를 동시에 할 수 있으며, 여러 번 가능.
- 다중 패스(multi-pass) 알고리즘에 문제 없이 쓸 수 있음.
- 단일 연결 리스트를 제공하는 (대개 이름이 slist) 컨테이너에 쓰는 반복자.

## 양방향 반복자(bidirectional iterator)

- 순방향 반복자에 뒤로 갈 수 있는 기능을 추가한 것.
- STL의 list에 쓰는 반복자.
- set, multiset, map, multimap 등의 컨테이너에도 사용됨.

## 임의 접근 반복자(random access iterator)

- 양방향 반복자에 반복자 산술 연산(iterator arithmetic) 수행 기능을 추가한 것.
- 주어진 반복자를 임의의 거리만큼 앞뒤로 이동시키는 일을 상수 시간 안에 할 수 있음.
- 기본제공 포인터를 본떠서 만들었기 때문에 포인터 산술 연산과 비슷함.
- C++ 표준 라이브러리의 vector, deque, string에 사용됨.

## 태그(tag) 구조체

다섯 개의 반복자 범주 각각을 식별하는 데 쓰임.

```cpp
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag: public input_iterator_tag {};
struct bidirectional_iterator_tag: public forward_iterator_tag {};
struct random_access_iterator_tag: public bidirectional_iterator_tag {};
```

구조체들 사이의 상속 관계를 보면 is-a 관계임.

public 상속은 파생 클래스 타입에도 작동하는 기본 클래스 타입용 코드를 작성할 수 있도록 한 것.

# 📌 STL의 advance

STL은 기본적으로 컨테이너(container) 및 반복자(iterator), 알고리즘(algorithm) 템플릿으로 구성됨.

이 외에 유틸리티(utility)라고 불리는 템플릿도 몇 개 들어있음.

이 중 하나가 advance로, **지정된 반복자를 지정된 거리(distance)만큼 이동시키는 것**.

```cpp
template<typename IterT, typename DistT> // iter를 d 단위만큼 전진시킴.
void advance(IterT& iter, DistT d);      // d < 0 이면 iter를 후진시킴.
```

간단히 개념만 보면, iter += d 하면 될 것 같지만, 사실 이렇게 구현할 수 없음.

`+=` 연산을 지원하는 반복자는 임의 접근 반복자밖에 없기 때문.

따라서, 다른 반복자 타입의 경우에는 `++` 혹은 `--` 연산을 d번 적용하는 것으로 구현함.

## 구현 1. 최소 공통 분모(lowest-common-denominator) 전략

- 반복자를 주어진 횟수만큼 반복적으로 한 칸씩 증가시키거나 감소시키는 루프 돌리기.
- 선형 시간이 걸림.
- 상수 시간의 반복자 산술 연산을 쓸 수 있는 임의 접근 반복자 입장에서는 손해.

## 구현 2. 상수 시간 연산을 이용하는 방법

```cpp
template<typename IterT, typename DistT>
void advance(IterT& iter, DistT d)
{
	if(iter가 임의 접근 반복자이다) {
		iter += d;    // 임의 접근 반복자에 대해서는 반복자 산술 연산을 사용.
	}
	else {
		if (d >= 0) { while (d--) ++iter; } // 다른 종류의 반복자에 대해서는
		else { while (d++) --iter; }       // ++ 혹은 -- 연산의 반복 호출을 사용함.
	}
}
```

위 코드가 제대로 되려면 iter 부분이 임의 접근 반복자인지 판단할 수 있는 수단이 있어야 함.

즉, iter의 타입인 IterT가 임의 접근 반복자 타입인지 알아야 함.

어떤 타입에 대한 정보를 얻어낼 필요가 있음.

# 📌 특성 정보(traits)

**컴파일 도중에 어떤 주어진 타입의 정보를 얻을 수 있게 하는 객체**를 지칭하는 개념.

- C++에 미리 정의된 문법구조가 아니며, 키워드도 아님.
- 그냥 C++ 프로그래머들이 따르는 구현 기법이며, 관례.

**특성정보가 되려면 기본제공 타입과 사용자 정의 타입에서 모두 돌아가야 함.**

- advance는 포인터(const char\* 등) 및 int를 받아서 호출될 때도 제대로 동작해야 함
- 정확한 의미 ⇒ **특성정보 기법을 포인터 등의 기본제공 타입에 적용**할 수 있어야 함.
  - 뒤집어서 생각하면, 어떤 타입 내에 중첩된 정보 등으로는 구현이 안 된다는 말.
  - 결국, 어떤 타입의 특성정보는 그 타입의 외부에 존재해야 함.

### **특성정보를 다루는 표준적인 방법**

해당 특성정보를 템플릿 및 그 템플릿의 1개 이상의 특수화 버전에 넣는 것.

반복자의 경우, 표준 라이브러리의 특성정보용 템플릿이 **`iterator_traits`** 이름으로 준비되어 있음.

```cpp
template<typename IterT>  // 반복자 타입에 대한 정보를 나타내는 템플릿
struct iterator_traits;
```

특성정보는 관례에 따라 항상 구조체로 구현.

**`특성정보 클래스` :** 특성정보를 구현하는 데 사용한 구조체.

**iterator_traits 클래스가 동작하는 방법**

- iterator_traits<IterT> 안에 IterT 타입 각각에 대해 iterator_category 라는 이름의 typedef 타입이 선언되어 있음.
- 이렇게 선언된 typedef 타입이 바로 IterT의 반복자 범주를 가리킴.
- iterator_traits 클래스는 이 반복자 범주를 두 부분으로 나누어 구현함.

# 📌 iterator_traits 구현

### 1. 사용자 정의 반복자 타입에 대한 구현.

사용자 정의 반복자 타입으로 하여금 iterator_category라는 이름의 typedef 타입을 내부에 가질 것을 요구사항으로 둠.

이때 이 typedef 타입은 해당 태그 구조체에 대응되어야 함.

- 예) deque의 반복자는 임의 접근 반복자이므로, deque 클래스(템플릿)에 쓸 수 있는 반복자는 다음과 같은 형태
  ```cpp
  template<...> // 템플릿 매개변수는 편의상 생략
  class deque {
  public:
  	class iterator {
  	public:
  		typedef random_access_iterator_tag iterator_category;
  		...
  	};
  	...
  };
  ```
  list의 반복자는 양방향 반복자이기 때문에 다음과 같이 되어있음
  ```cpp
  template<...>
  class list {
  public:
  	class iterator {
  	public:
  		typedef bidirectional_iterator_tag iterator_category;
  		...
  	};
  	...
  };
  ```

이 iterator 클래스가 내부에 지닌 중첩 typedef 타입을 똑같이 쓴 것이 iterator_traits

```cpp
// IterT 타입에 대한 iterator_category는 IterT가 온몸으로 말하고 있는 바 그대로임.
// typedef typename이 사용된 부분에 대한 설명은 항목 42 참고
template<typename IterT>
struct iterator_traits {
	typedef typename IterT::iterator_category iterator_category;
	...
};
```

위 코드는 사용자 정의 타입에 대해서는 잘 돌아가지만, 반복자의 실제 타입이 포인터인 경우엔 안 돌아감.

포인터 안에 typedef 타입이 중첩된다는 것부터가 말이 안되기 때문.

### 2. 반복자가 포인터인 경우의 처리

포인터 타입의 반복자를 지원하기 위해, iterator_traits는 포인터 타입에 대한 **`부분 템플릿 특수화(partial template specialization)`** 버전을 제공하고 있음.

사실 포인터의 동작 원리가 임의 접근 반복자와 똑같으므로, iterator_traits가 이런 식으로 지원하는 반복자 범주가 바로 임의 접근 반복자임.

```cpp
template<typename IterT>        // 기본제공 포인터 타입에 대한 부분 템플릿 특수화
struct iterator_traits<IterT*>
{
	typedef random_access_iterator_tag iterator_category;
	...
};
```

### **특성정보 클래스의 설계 및 구현 방법**

- 다른 사람이 사용하도록 열어 주고 싶은 타입 관련 정보를 확인. (예, 반복자라면 반복자 범주 등)
- 그 정보를 식별하기 위한 이름을 선택. (예: iterator_category)
- 지원하고자 하는 타입 관련 정보를 담은 템플릿 및 그 템플릿의 특수화 버전 (예: iterator_traits)을 제공.

iterator_traits가 주어졌으므로, advance의 의사코드를 다음과 같이 다듬을 수 있음.

(C++ 표준 라이브러리의 일부이므로, 실제로는 std::iterator_traits임)

```cpp
template<typename IterT, typename DistT>
void advance(IterT& iter, DistT d)
{
	if(typeid(typename std::iterator_traits<IterT>::iterator_category)
			== typeid(std::random_access_iterator_tag))
	...
}
```

컴파일 문제 (항목 48에서 자세히 설명)

### **더 근본적인 문제점**

IterT의 타입은 컴파일 도중에 파악되기 때문에, iterator_traits<IterT>::iterator_category를 파악할 수 있는 때도 컴파일 도중임. 하지만 if 문은 프로그램 실행 도중에 평가됨.

**컴파일 도중에 할 수 있는 것을 실행 도중에 해야하니 시간 낭비, 실행 코드의 크기도 커짐.**

지금 필요한 것 ⇒ 주어진 타입에 대한 평가를 컴파일 도중에 수행하는 조건처리 구문요소(if …else문 같은).

이런 효과를 얻을 수 있는 방법 ⇒ **`오버로딩`**

어떤 함수 f를 오버로딩 ⇒ 매개변수 리스트가 다르지만 f라는 이름은 같은 오버로드 버전을 여러 개 만듦.

이 상태에서 f를 호출하면, 컴파일러는 인자를 보고 호출 시의 전후관계에 가장 맞는 오버로드 버전을 고름.

사실 컴파일러의 의도는 아래와 같음.

넘긴 인자 타입에 가장 잘 맞는 오버로드 버전이 이거면, 이 f를 호출할 거고. 이게 아니라 두 번째로 고른 오버로드 버전이 잘 맞는다면 이걸 호출할 거고, 세 번째로 고른 게 딱 맞으면 그걸 호출할거다.

컴파일 타임에 타입에 따라 선택되는 조건처리 구문요소가 바로 이것.

이걸 써서 advance가 우리가 원하는 대로 동작하게 만들면 됨.

## ✅ 오버로딩 사용

advance의 동작 원리 알맹이는 똑같게 하고, 받아들이는 iterator_category 객체의 타입을 다르게함.

```cpp
template<typename IterT, typename DistT> // 임의 접근 반복자
void doAdvance(IterT& iter, DistT d, std::random_access_iterator_tag)
{
	iter += d;
}

template<typename IterT, typename DistT> // 양방향 반복자
void doAdvance(IterT& iter, DistT d, std::bidirectional_iterator_tag)
{
	if(d >= 0) { while (d--) ++iter; }
	else { while (d++) --iter; }
}

template<typename IterT, typename DistT> // 입력 반복자
void doAdvance(IterT& iter, DistT d, std::input_iterator_tag)
{
	if (d < 0) {throw std::out_of_range("Negative distance"); } // 자세한 내용은 아래에
	while (d--) ++iter;
}
```

forward_iterator_tag는 input_iterator_tag로부터 상속을 받은 것이므로, input_iterator_tag를 매개변수로 받는 doAdvance는 순방향 반복자도 받을 수 있음.

advance는 임의 접근 반복자 및 양방향 반복자에 대해 양수 및 음수 거리를 받을 수 있게 되어 있지만, 순방향 반복자나 입력 반복자를 음수 거리만큼 이동하려고 하면 미정의 동작이 발생함.

d에 음수 거리가 인자로 넘어올 경우 무한 루프에 빠질 수 있으므로, 예외 던지는 루틴 넣음.

이제 advance는 오버로딩된 doAdvance를 호출하면 됨.

컴파일러가 오버로딩 모호성 해결을 통해 적합한 버전을 호출할 수 있도록 반복자 범주 타입 객체를 맞추어 전달해야 함.

```cpp
template<typename IterT, typename DistT>
void advance(IterT& iter, DistT d)
{
	// iter의 반복자 범주에 적합한 doAdvance의 오버로드 버전을 호출
	doAdvance(iter, d, typename std::iterator_traits<IterT>::iterator_category());
}
```

# 📌 요약

**특성정보 클래스 사용 방법**

- 작업자(worker) 역할을 맡을 함수 혹은 함수 템플릿(예: doAdvance)을 특성정보 매개변수를 다르게 하여 오버로딩.
  그리고 전달되는 해당 특성정보에 맞춰 각 오버로드 버전을 구현.
- 작업자를 호출하는 주작업자(master) 역할을 맡을 함수 혹은 함수 템플릿(예: advance)을 만듦.
  이때 특성정보 클래스에서 제공되는 정보를 넘겨서 작업자를 호출하도록 구현.
