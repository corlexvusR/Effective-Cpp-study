# 항목 48: 템플릿 메타프로그래밍, 하지 않겠는가? - 작성자: 서무성

<aside>
🔎

# 이것만은 잊지말자!

- 템플릿 메타프로그래밍은 기존 작업을 런타임에서 컴파일 타임으로 전환하는 효과를 냅니다. 따라서 TMP를 쓰면 선행 에러 탐지의 높은 런타임 효율을 손에 거머쥘 수 있습니다.
- TMP는 정책 선택의 조합에 기반하여 사용자 정의 코드를 생성하는 데 쓸 수 있으며, 또한 특정 타입에 대해 부적절한 코드가 만들어지는 것을 막는 데도 쓸 수 있습니다.
</aside>

---

---

### 템플릿 메타프로그래밍(Template Metaprogramming, TMP)

- 컴파일 도중에 실행되는 템플릿 기반의 프로그램을 작성하는 기법
- 컴파일러가 이 프로그램을 실행하면 그 결과로 C++ 소스 코드가 생성되고, 이 코드가 다시 일반적인 컴파일 과정을 거치게 됩니다.

### TMP 장점

1. TMP를 쓰면 다른 방법으로는 까다롭거나 불가능한 일을 굉장히 쉽게 할 수 있다.
2. TMP는 C++ 컴파일이 진행되는 동안에 실행되기 때문에, 기존 작업을 런타임 영역에서 컴파일 타임 영역으로 전환이 가능하다.
    - 이를 통해서 두 가지 이득을 얻을 수 있다.

1. 일반적으로 프로그램 실행 도중에 잡혀 왔던 몇 몇 에러들을 컴파일 도중에 찾을 수 있다
2. TMP를 쓴 C++ 프로그램이 모든 면에서 효율적일 여지가 많다는 점
    - 컴파일 타임에 동작을 해서 오기 때문에, 실행 코드가 작아지고, 실행 시간이 짧아지며, 메모리도 적게 잡아먹는다.
    - 대신 컴파일 타임이 길어지는 결과가 나타난다. (TMP 쓴 프로그램은, TMP 사용하지 않은 프로그램과 비교해서 컴파일 시간이 꽤 김)

### 47의 소스코드로 보는 예시

- STL의 advance에 대한 유사코드

```cpp
template<tympename IterT, typename DistT>
void advance (IterT& Dist d)
{
		if (iter) // iter가 임의 접근 반복자
		{
				iter += d; // 임의 접근 반복자에 대해서는 반복자 산술 연산을 사용
		}
		
		else {
				if(d >= 0) { while(d--) ++iter; } // 다른 종류의 반복자에 대해서는
        else { while (d++) --iter; }      // ++혹은 --연산의 반복 호출 사용
    }
```

- 실제 코드(타입 정보를 꺼내는 작업을 런타임에 하겠다는 것)

```cpp
template<typename IterT, typename DistT>
void advance(IterT& iter, DistT d)
{
    // typeid 연산자를 사용한다.
    if(typeid(typename std::iterator_traits<IterT>::iterator_category ==
       typeid(std::random_access_iterator_tag))
    {
        iter += d;
    }
    else
    {
        if(d >= 0) { while(d--) ++iter; }
        else { while (d++) --iter; }
    }
}
```

- typeid 연산자를 쓰는 방법은 특성정보(traits)를 쓰는 방법보다 효율이 떨어짐
    - 타입 점검 동작이 컴파일 도중이 아니라 런타임에 일어나기 때문
    - 런타임 타입 점검을 수행하는 코드는 실행 파일에 들어가야 하기 때문
    - 특성 정보를 사용하면 타입에 따른 if, else 처리를 컴파일 타입에 사용 가능

- TMP를 사용한다면
    - 주어진 타입에 따른 코드가 별도로 함수로 분리될 것이다.
    - 각각의 함수는 자신이 맡은 타입에 대한 연산만 수행할 것이다.
    - 토글
        
        ```cpp
        #include <iterator> // std::iterator_traits 및 태그 포함
        #include <stdexcept> // std::out_of_range (input_iterator 경우)
        
        // --- 작업자(Worker) 함수 템플릿 (**새로 추가됨**) ---
        // --- 타입 확인 로직이 각 오버로드 함수로 분리됨 ---
        
        // 1. 임의 접근 반복자(Random Access Iterator) 버전
        template<typename IterT, typename DistT>
        void doAdvance(IterT& iter, DistT d,
                       **std::random_access_iterator_tag**) // **태그 타입으로 오버로딩**
        {
            iter += d; // += 연산 사용
        }
        
        // 2. 양방향 반복자(Bidirectional Iterator) 버전
        template<typename IterT, typename DistT>
        void doAdvance(IterT& iter, DistT d,
                       **std::bidirectional_iterator_tag**) // **태그 타입으로 오버로딩**
        {
            // **이전 else 블록의 로직**
            if (d >= 0) { while (d--) ++iter; }
            else { while (d++) --iter; }
        }
        
        // 3. 입력 반복자(Input Iterator) 버전
        template<typename IterT, typename DistT>
        void doAdvance(IterT& iter, DistT d,
                       **std::input_iterator_tag**) // **태그 타입으로 오버로딩**
        {
            // **이전 else 블록의 로직 (음수 거리 처리 추가)**
            if (d < 0) {
                throw std::out_of_range("Negative distance for input iterator");
            }
            while (d--) ++iter;
        }
        
        // --- 주 작업자(Master) 함수 템플릿 ---
        
        template<typename IterT, typename DistT>
        void advance(IterT& iter, DistT d)
        {
            // **typeid 기반 if문 대신 iterator_traits 사용**
            **typename std::iterator_traits<IterT>::iterator_category category;**
        
            // **오버로딩된 doAdvance 호출 (태그 객체 전달)**
            **doAdvance(iter, d, category);**
        }
        ```
        

### typeid 방법은 성능 외에도 컴파일 문제를 일으킬 수 있다.

- 예시
    
    ```cpp
    void advance(std::list<int>::iterator& iter, int d)
    {
        if(typeid(std::iterator_traits<std::list<int>::iterator>::iterator_category) == typeid(std::random_access_iterator_tag))
        {
            **iter += d;** // **에러 발생**
        }
        else
        {
            if(d >= 0) { while(d--) ++iter; }
            else { while (d++) --iter; }
        }
    }
    
    std::list<int>::iterator iter;
    ...
    **advance(iter, 10)**; // iter를 10개 원소만큼 앞으로 옮기려고 했으나
    									 // 이렇게 구현된 advance로는 **컴파일이 안된다.**
    ```
    
    - list<int>::iterator는 양방향 반복자이기 때문에 += 연산을 지원하지 못함
    - +=은 임의 접근 반복자에서만 가능하다.
    - 사실 if 문의 list<int>::iterator에 대해 typeid 점검이 실패해서 +=까지 실행안됨
        - 모든 소스 코드가 제대로 되어 있는지 확인하는 일은 컴파일러의 책무

### TMP의 튜링 완전성

- 범용 프로그래밍 언어처럼 어떤 것이든 계산할 수 있는 능력을 갖추고 있다.
(계산 시스템(컴퓨터, 프로그래밍 언어 등)이 **이론적으로 풀 수 있는 모든 계산 문제를 풀 수 있는 능력)**
- 변수 선언도 되고, 루프도 실행시킬 수 있고, 함수를 작성하고 호출하는 것까지 된다.
- C++의 구문 요소들과는 다른 모습을 가지고 있다.

### TMP 구문 요소

- if … else 조건문을 나타내는 통상의 if 문이 아닌 템플릿 특수화 버전을 사용
    - 항목 55에 TMP 라이브러리 있으니 참고
- TMP에는 반복(iteration) 의미의 진정한 루프는 없고, 재귀(recursion)를 사용해서 루프의 효과를 낸다.
    - TMP의 루프는 재귀 함수 호출을 만드는 것이 아니라 재귀식 템플릿 인스턴스화(recursive template instantiation)를 사용
    
    ```cpp
    // TMP 계승 계산방법(팩토리얼)
    
    template<unsigned n> // 일반적인 경우: Factorial<n>의 값은
    										 // Factorial<n-1>에 n을 곱해서 구함
    struct Factorial
    {
        enum { value = n * Factorial<n-1>::value };
    };
    
    template<>                 // 특수한 경우: Factorial<0>의 값은 1
    struct Factorial<0>
    {
        enum { value = 1; };
    };
    ```
    
    - 템플릿 메타프로그램이 있으면, Factorial<n>::value를 참조함으로써 n의 계승을 얻을 수 있다.
    - Factorial 템플릿은 구조체 타입이 인스턴스화되도록 만들어져 있다.
        - 구조체 안에는 value라는 이름의 TMP 변수가 선언되어 있는데, 이것은 항목 2에서 사용한 나열자 둔갑술(enum hack)이 쓰인 것.
        - `Factorial<n>::value` 를 참조함으로 n의 계승을 바로 얻을 수 있다.
- TMP 사용 방법
    
    ```cpp
    int main(){
        std::cout << Factorial<5>::value; // 런타임 계산 없이 출력
        std::cout << Factorial<10>::value;
    }
    
    // 이 코드가 혹시 국민 여동생 여배우보다 더 상큼해 보이시는 분?
    ```
    

### C++에서 TMP 실력 발휘 예시

1. 치수 단위(dimensional unit)의 정확성 확인
    - 과학 기술 분야의 응용프로그램은 치수 단위(질량, 거리, 시간 등)가 똑바로 조합되어야하는 것이 최우선이다.
    - 속도를 나타내는 변수에 질량 넣으면 에러
    - TMP를 사용하면 프로그램 안에서 쓰인 치수 단위의 조합이 제대로 됐는지 컴파일 동안 볼 수 있다. → 선행 에러 탐지
    - 분수식 지수 표현이 지원이 된다.(time 1/2와 time 4/8이 동일하다고 보기 위해 약분 기능이 있음)
2. 행렬 연산의 최적화
    
    ```cpp
    typedef SquareMatrix<double, 10000> BigMatrix;
    BigMatrix m1, m2, m3, m4, m5;  // 행렬 생성, 
    ...                            // 행렬 값 대입
    BigMatrix result = m1 * m2 * m3 * m4 * m5; // 행렬에 곱을 계산
    ```
    
    - 보통 방법으로 사용하려면
        - 네 개의 임시 행렬 생성
        - 네 개의 루프가 순차적으로 만들어지는 비싼 연산 발생
    - 표현식 템플릿(expression template)을 사용
        - 덩치 큰 임시 객체를 없애는 것은 물론, 루프까지 합칠 수 있다.
        - 메모리도 적게 쓰고 속도는 빨라짐
    
3. 맞춤식 디자인 패턴 구현의 생성
    - 전략(Sttrategy) , 감시자(Observer) , 방문자(Visitor) 패턴 등의 디자인 패턴은 구현 방법이 여러 가지이다.
    - TMP를 사용한 프로그래밍 기술인 정책 기반 설계(policy-based design)을 사용하면.
        - 따로따로 마련된 설계상의 선택(정책)을 나타내는 탬플릿을 만들어낼 수 있다.
        - 이 정책 템플릿을 임의로 조합하여 사용자의 취향에 맞게 패턴을 구현할 때 사용한다.
        - 예를 들어 스마트 포인터 동작 정책을 하나씩 구현한 각각의 템플릿을 만들고, 사용자가 마음대로 조합하여 수백 가지의 스마트 포인터 타입을 생성할 수 있게 하는 것(컴파일 도중에)
        - 생성식 프로그래밍(generative programming)의 기초.

### **TMP 단점**

- 문법이 비 직관적이고 개발도구의 지원도 아주 미약
- 비교적 최근 발견된 것으로 TMP의 프로그래밍 관례들도 아직 미약
- 그럼에도 불구하고 컴파일 타임에 수행하는 장점으로 매력이 있으며 점점 내외적 지원과 관련 서적들이 늘어가고 있다.
- 라이브러리 개발자는 알아야 함

<aside>
🔎

# 이것만은 잊지말자!

- 템플릿 메타프로그래밍은 기존 작업을 런타임에서 컴파일 타임으로 전환하는 효과를 냅니다. 따라서 TMP를 쓰면 선행 에러 탐지의 높은 런타임 효율을 손에 거머쥘 수 있습니다.
- TMP는 정책 선택의 조합에 기반하여 사용자 정의 코드를 생성하는 데 쓸 수 있으며, 또한 특정 타입에 대해 부적절한 코드가 만들어지는 것을 막는 데도 쓸 수 있습니다.
</aside>