 # 항목 54: TR1 을 포함한 표준 라이브러리 구성요소와 편안한 친구가 되자 - 작성자: 서무성

<aside>
🔎

# 이것만은 잊지말자!

- 최초에 상정된 표준 C++ 라이브러리의 주요 구성요소는 STL, iostream, 로케일 등입니다. 여기에는 C89의 표준 라이브러리도 포함되어 있습니다.
- TR1이 도입되면서 추가된 것은 스마트 포인터(tr1::shared_ptr 등), 일반화 함수 포인터(tr1::function), 해시 기반 컨테이너, 정규 표현식 그리고 그 외에 10개 구성요소입니다.
- TR1 자체는 단순히 명세서일 뿐입니다. TR1의 기능을 사용하기 위해서는 명세를 구현한 코드를 구해야 합니다. TR1 구현을 구할 수 있는 자료처 중 한 군데가 바로 부스트입니다.
</aside>

### TR(Tehinical Report)

- 기술보고서
- C++의 다음 정식 버전에 추가될 기능들을 미리 모아서 발표한 예고편 또는 중간 업데이트
- C++ 표준 자체를 개정하는 것은 매우 오래 걸리기 때문에, shared_ptr, function, 해시테이블과 같은 유용하고 검증된 기능들을 TR1이라는 이름으로 명세화하여 컴파일러 제작사가 구현하고 개발자들이 미리 사용하게 한 것

### C++98에 명시되어 있는 표준 C++ 라이브러리 주요 구성요소

- 표준 템플릿 라이브러리(Standard Template Library: STL)
    - 주요 구성요소로서 컨테이너(vector, string, map 등), 반복자, 알고리즘(find, sort, transform 등), 함수 객체(less, greater 등) 외에 이런저런 컨테이너 어댑터와 함수 객체 어댑터(stack, priority_queue, mem_fun, not1 등)가 있다.
- iostream
    - 사용자 정의 버퍼링, 국제화 기능이 가능한 입출력을 지원, cin, cout, cerr, clog 등의 사전정의 객체 지원
- 국제화 지원
    - 여러 로케일(locale)을 활성화시킬 수 있는 기능이 포함되어 있습니다. 또한 wchar_t 등의 타입(대개 16비트/문자) 및 wstring(wchar_t 타입으로 정의한 string)을 쓰면 유니코드를 사용할 수 있다.
- 수치 처리 지원
    - 복소수를 나타내는 템플릿(complex) 및 수치 배열을 나타내는 탬플릿(valarray)이 여기에 해당됩니다.
- 예외 클래스 계통
    - 최상위 클래스인 exception 및 파생 클래스들, ex: logic_error 및 runtime_error
- C89의 표준 라이브러리
    - 1989년 버전의 C에 포함된 표준 라이브러리는 전부 C++에 포함

https://en.cppreference.com/w/cpp/headers.html

### TR1을 통해 명시된 새로운 14개의 구성요소

- 14개 모두 std 네임스페이스에 들어있고, 중첩된 tr1이란 네임스페이스에 들어있다.
    - std::tr1::shared_ptr
- 스마트 포인터(smart pointer)
    - 동작은 기본제공 포인터와 똑같으나, 하나의 실체 객체를 가리키는 자신과 같은 포인터의 개수를 유지해 놓는 똑똑한 포인터. 이런 기법을 참조 카운팅(reference counting)이라고 함.
- tr1::function
    - 어떤 함수가 가진 시그니처(signature)와 호환되는 시그니처를 가지는 함수호출성 개체(callable entity)의 표현을 가능하게 해주는 템플릿. 시그니처가 비슷하면 호출이 가능한 일반화 콜백 함수를 만들자는 것이 주요 개념
    
    ```cpp
    void registerCallback(std::string func(int));
    // int를 받고 string을 반환하는 함수가 매개변수 타입
    // std::string (int)가 시그니처
    
    void registerCallback(std::string (int)); // 위와 동일 매개변수 이름x
    
    "2"  "2"
    void registerCallback(std::tr1::function<std::string (int)>func);
    // 함수 시그니처 대신에 임의의 함수호출성 개체를 받도록 만들게 해서 int 타입 혹은 int로 변환이 가능한 어떤 타입도 전달받으며 string 혹은 string으로 변환이 가능한 타입도 반환할 수 있는 함수를 registerCallback의 매개변수로 설정
    // std::string (int)와 호환되는 시그니처를 갖는 어떤 함수호출성 개체도 됨
    ```
    
- tr1::bind
    - STL 바인더로 사용되는 bind1st, bind2nd와 동작은 같음. 근데 더 많은 기능이 있는 범용 바인더임. bind는 상수 멤버 함수 및 비상수 멤버 함수에 상관없이 동작.
    - 참조로 전달되는 매개변수에 대해서도 동작.
    - 외부 보조 없이도 함수 포인터를 자체적으로 다룰 수 있다.
- 해시 테이블(hash table)
    - TR1의 해시기반 컨테이너는 원소가 저장되는 순서를 예측할 수 없다는 점이 강조됨
    - tr1::unordered_set, tr1::unordered_multiset, tr1::unordered_map, tr1::unordered_multimap
- 정규 표현식(regular expreesion)
    - 정규 표현식 기반의 탐색과 문자열에 대한 대체 연산이 가능하고, 일치되는 원소들 사이의 순회도 지원한다.
- 튜플(tuple)
    - 기존 pair 템플릿의 새로운 버전. pair 객체는 2개만 담을 수 있지만 tr1::tuple은 몇 개라도 담을 수 있다.
- tr1::array
    - begin, end 등의 멤버 함수 지원하는 배열. tr1::array의 객체의 크기는 컴파일 과정에서 고정되므로 동적메모리를 사용하지 않는다.
- tr1::mem_fn
    - 멤버 함수 포인터를 적응시키는 용도에 쓸 수 있는 템플릿
    - mum_fun 및 mem_fun_ref의 기능을 그대로 사용하며 기능을 확장함
- tr1::reference_wrapper
    - 기존의 참조자가 객체처럼 행세할 수 있도록 만들어주는 템플릿
- 난수발생
    - C에서 물려받은 rand 함수보다 몇 배는 우수한 난수 발생 기능
    - 메르센 트위스터라는 복잡하고 정교한 알고리즘을 사용해 통계적으로 훨씬 더 무작위적이고 예측 불가능하다고 하네요..
    - 정규분포도 가능하다고 하네요..
- 특수용도의 수학함수
    - 라게르(Laguerre) 다항식, 베셀(Bessel) 함수, 완전 타원 적분 등 많이 있다.
- C99 호환성 확장 기능
    - C99의 새로운 라이브러리를 C++로 가져올 목적으로 설계된 함수 및 템플릿 모음

### 템플릿 프로그래밍 같은 기법을 지원하는 기술

- 타입 특성정보(type traits)
    - T라는 타입에 대해 T가 기본제공 타입인지
    - 가상 소멸자를 지원하는지
    - 공백클래스인지
    - 암시적 변환이 가능한지 등의 정보를 알 수 있다.
    - 적절한 바이트 정렬까지 잡아낸다.
- tr1::result_of
    - 함수 호출의 반환 타입을 추론해 주는 템플릿

### TR1은 그냥 문서

- 이 문서에 명시된 기능을 맛보려면 구현된 코드를 구해야함
- 지금 TR1의 14개 구성요소 중 10개는 부스트에서 무료로 공개한 라이브러리 기반
- 찾아보면 있을거임(근데 지금 C++23일텐데 이게 지금 다 들어가 있을 듯?)