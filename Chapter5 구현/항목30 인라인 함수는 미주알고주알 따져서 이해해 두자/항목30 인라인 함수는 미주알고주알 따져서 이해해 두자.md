# 항목 30: 인라인 함수는 미주알고주알 따져서 이해해 두자 - 작성자: 서무성

<aside>
🔎

# 이것만은 잊지말자!

- 함수 인라인은 작고 자주 호출되는 함수에 대해서만 하는 것으로 묶어둡시다. 이렇게하면 디버깅 및 라이브러리의 바이너리 업그레이드가 용이해지고 자칫 생길 수 있는 코드 부풀림 현상이 최소화되며, 프로그램의 속력이 더 빨라질 수 있는 여지가 최고로 많아집니다.
- 함수 템플릿이 대개 헤더 파일에 들어간다는 일반적인 부분만 생각해서 이들을 inline으로 선언하면 안 됩니다.
</aside>

---

### 용어 설명

```smalltalk
아웃라인(outline) 함수: 일반적인 함수 호출을 뜻한다. 함수의 본문을 그대로 끼워 넣는다는 뜻의 인라인 함수와 반대로, 보통의 함수 호출은 개요만을 써 놓는 것과 같다는 의미로 생각하면 무리가 없을 둣.아웃라인 함수란 용어는 인라인 함수의 뜻을 부각시키기 위해 이후에도 계속 같은 의미로 사용하였다. 一옮긴이
```

---

### ❗파트 요약: 인라인 함수(Inline Function)란 무엇이며, 언제 어떻게 사용해야 효과적인가? 에 대해 설명하는 파트

---

### 인라인 함수

- 함수처럼 보이고, 함수처럼 동작하고, 매크로보다 훨씬 안전하고 쓰기 좋다.
- 함수 호출시 발생하는 오버헤드를 걱정하지 않아도 된다.
- 컴파일러가 함수 본문에 대해 문맥별(context-specific) 최적화를 걸기가 용이하다.

- 인라인 함수
    - **인라인 함수**는 컴파일러에게 함수 호출 코드를 함수 본문으로 대체해달라고 **요청**하는 기능. 이 요청이 받아들여지면, 프로그램 실행 시 함수를 호출하는 데 드는 오버헤드를 없앨 수 있다.
    
    **예제**
    
    ```cpp
    #include <iostream>
    
    inline void PrintHello() {
        cout << "Hello, World" << endl;
    }
    
    int main() {
        PrintHello();
        PrintHello();
        return 0;
    }
    
    ---- 컴파일 과정에서 변경 ---
    
    #include <iostream>
    
    int main() {
        cout << "Hello, World" << endl;
        cout << "Hello, World" << endl;
        return 0;
    }
    
    // 인라인 함수(inline function)는 컴파일러가 함수를 호출하는 대신, 그에 대응하는 함수 코드로 대체하여 호출되는 모든 장소에 삽입할 것을 요청
    ```
    
    **문맥별 최적화**
    
    ```cpp
    inline void checkValue(int x) {
        if (x > 10) {
            // 복잡한 작업 A
        } else {
            // 복잡한 작업 B
        }
    }
    
    checkValue(5);
    
    // 문맥별 최적화가 없다면, 프로그램은 checkValue 함수를 호출하고 x > 10 이라는 조건을 실행 시간에 검사해야 함.
    // 최적화 checkValue(5) 호출을 if (5 > 10) 코드로 대체. 컴파일러는 5 > 10이 거짓이라는 것을 컴파일 시간에 이미 알고 있으므로, if문 전체와 '복잡한 작업 A' 코드를 완전히 삭제하고 '복잡한 작업 B' 코드만 남김
    ```
    
    **함수 발생시 오버헤드**
    
    ![image.png](attachment:6091bc6c-c001-4d42-81de-ba5123ab58d8:image.png)
    
    - 코드 상에서 함수를 호출하면 스택에 있는 함수 위치를 찾기
    - 함수의 값을 가지고 복귀하는 주소를 기억해야 하는 이 과정들을 줄인다는 뜻 같음.
    
    https://blog.naver.com/ycpiglet/222818854483
    
    https://boycoding.tistory.com/220
    
    https://coding-factory.tistory.com/694
    

### 인라인 요청 방법(암시적)

- 클래스 정의 안에 함수를 직접 구현하면 컴파일러는 해당 함수를 인라인 후보로 간주한다.
- 대게 멤버 함수이지만, 항목 46을 참고하면 프렌드 함수도 클래스 내부에서 정의 될 수 있다.

```cpp
class Person {
	public:
		...
	  int age() const { return theAge; } // 암시적인 인라인 요청 : age는 
		...                                // 클래스 정의 내부에서 정의되었습니다
	private:
	  int theAge;
};
```

### 인라인 요청 방법(명시적)

- 함수 정의 앞에 `inline` 키워드를 붙여준다.

```cpp

template<typename T>
// std::max 앞에 "inline"을 붙여 명시적으로 inline 요청함
inline const T& std::max(const T& a, const T& b)
    return a < b ? b : a;
}
```

### 인라인 함수는 대체적으로 헤더 파일에 저장되어야 한다.

- 대부분의 빌드 환경이 인라인을 컴파일 도중에 실행하기 때문
- 인라인 함수 호출을 함수의 본문으로 바꿔치기 하려면, 함수가 어떤 형태인지 컴파일러가 알아야 하기 때문
- 템플릿도 대체적으로 헤더 파일에 있어야 맞다.
- 템플릿 사용 부분에서 해당 템플릿을 인스턴스로 만들려면 컴파일러가 어떻게 생겼는지 알아야 하기 때문이다.
- 대세는 컴파일 타임에 템플릿 인스턴스화를 진행한다.
    - 어떤 빌드 환경은 링크 도중에 템플릿 인스턴스화를 수행함

### 인라인은 요청이다.

- 인라인 함수로 선언이 되어 있어도 컴파일러가 보기에 복잡한 함수는 절대로 인라인 대상에 넣지 않는다.
    - 루프가 들어있거나
    - 재귀 함수인 경우
    - **가상 함수 호출**의 경우
    
- 가상 함수 호출
    - virtual의 의미는 "어떤 함수를 호출할지 결정하는 작업을 런타임에 결정한다”
    - inline의 의미는 "함수 호출 위치에 호출된 함수를 끼워넣는 작업을 프로그램 실행 전에 한다.”
    - 의미 상충
    
- 인라인 함수의 여부는 사용자의 빌드 환경(컴파일러)에 따라 다름

### 완벽한 인라인 조건을 갖추어도 인라인이 되지 않는 경우

- 인라인 함수의 주소를 취하는 코드가 있으면, 컴파일러는 아웃라인 함수 본문을 만들 수 밖에 없다.
    - 있지도 않은 함수에 대해 포인터를 가져올 수 없기 때문

- 인라인 함수로 선언된 함수를 함수 포인터를 통해 호출하는 경우

```cpp
inline void f() {...} // 이 f 호출은 컴파일러가 반드시 인라인한다고 가정
 
void (*pf)() = f;     // pf는 f를 가리키는 함수 포인터
...
f();                  // 평범한 함수 호출이니까 인라인이 될 것

pf();                 // 이 호출은 인라인되지 않을 것. 함수 포인터를 통해 호출
```

### 생성자와 소멸자는 인라인하기에 좋지 않은 함수

```cpp
class Base{
public:
    ...
private:
    string bm1, bm2;         // Base 클래스의 멤버 (bm) 1, 멤버 2
};

classs Derived : public Base
{
public:
    Derived() {}             // Derived의 생성자가 비어 있습니다.
													   // 진짜 비어 있을까요?
    ...
private:
    string dm1, dm2, dm3;
};
```

- Derived의 생성자는 생김새부터 인라인하기에 딱 좋아 보인다.
- C++는 객체가 생성되고 소멸될 때 여러 가지 보장을 준비한다.
    - new를 하면 동적으로 만들어지는 객체를 생성자가 자동으로 초기화
    - delete를 하면 대응되는 소멸자가 호출되는 것 등등
    - 즉 컴파일러가 코드를 만들어서 컴파일 도중에 코드를 삽입한다.
    - 글쓴이가 생각하는 컴파일러 코드
        
        ```cpp
        // "비어 있는" Derived 생성자가 실제로 구현된다면 이런 모습일지도 모른다고 꾸며 본 개념적인 코드
        Derived::Derived() {
            
            Base::Base(); // Base 부분을 초기화합니다.
        
            
            try {
                dm1.std::string::string(); // dm1의 생성을 시도합니다.
            } catch (...) {
                // 생성 도중에 dm1에서 예외를 던지면,
                // 기본 클래스 부분을 소멸시키고
                Base::~Base();
                // 그 예외를 전파합니다(다시 던집니다).
                throw;
            }
        
            // dm2의 생성을 시도합니다.
            try {
                dm2.std::string::string();
            } catch (...) {
                // 생성 도중에 dm2에서 예외를 던지면,
                // dm1을 소멸시키고
                dm1.std::string::~string();
                // 기본 클래스 부분을 소멸시킨 후에
                Base::~Base();
                // 그 예외를 전파합니다.
                throw;
            }
        
            // dm3의 생성을 시도합니다.
            try {
                dm3.std::string::string();
            } catch (...) {        // 생성 도중에 dm3에서 예외를 던지면,
                dm2.std::string::~string();// dm2를 소멸시키고
                dm1.std::string::~string(); // dm1을 소멸시키고
                Base::~Base();        // 기본 클래스 부분을 소멸시킨 후에
                throw;                // 그 예외를 전파합니다.
            }
        }
        ```
        
    - 비어있어 보여도 생각보다 비대하고, 상속이 복잡할수록 더 비대해지므로 인라인이 적합하지 않아요

### 라이브러리 설계자는 inline으로 선언할 때 많은 고민을 해야한다

- 라이브러리 차원에서 바이너리 업그레이드를 제공하지 않음
    - 라이브러리 사용자가 f의 본문을 컴파일해서 응용프로그램을 만들었다고 가정
    - 라이브러리 개발자가 f를 바꾸면 사용자들은 각자의 소스를 다시 컴파일해야함
    - f가 일반 함수라면 링크만 다시 해주면 됨(동적 링크면 알아서 되나 봄)

### 인라인에 대한 기본 전략

1. 아무것도 인라인하지 마세요.
2. 꼭 인라인해야 하는 함수(항목_46 참조)혹은 정말 단순한 함수에 한해서만 인라인 함수로 선언하자.
3. 디버거를 제대로 쓸 수 있도록 만들고, 정말 필요한 위치에 인라인 함수를 놓자.

→ 이유: 디버그 시 함수에 중단점을 걸 수 없기 때문이다. (근데 빌드 환경마다 다름)

### 결론 80-20 법칙을 따르자

- 대부분의 프로그램은 전체 실행 시간의 80%를 전체 코드의 20%가 차지한다는 '80-20 법칙'을 따릅니다.  따라서 모든 함수를 인라인하기보다, 성능에 결정적인 영향을 미치는 **20%의 작고 자주 호출되는 함수**를 찾아내어 전략적으로 인라인하는 것이 가장 효과적입니다.