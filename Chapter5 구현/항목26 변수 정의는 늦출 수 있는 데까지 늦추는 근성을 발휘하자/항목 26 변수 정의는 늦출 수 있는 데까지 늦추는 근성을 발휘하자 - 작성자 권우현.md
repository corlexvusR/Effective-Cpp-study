# 항목 26: 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자 - 작성자: 권우현

<aside>

# 💡이것만은 잊지말자!

- 변수 정의는 늦출 수 있을 때까지 늦춥시다. 프로그램이 더 깔끔해지며 효율도 좋아집니다.
</aside>

---

# 1. 개요

생성자, 소멸자와 관련된 변수를 정의할때 반드시 물게 되는 비용이 두개 존재

- 프로그램 제어 흐름이 정의에 닿을 때 생성자가 호출되는 비용
- 그 변수가 유효범위를 벗어날 때 소멸자가 호출되는 비용

⇒ 변수가 정의 됐으나 사용 되지 않는 경우에도 비용이 부과 됨.

⇒ 왜? 사용하지 않을 변수를 정의하게 되는가?

# 2. 예 1)

- 주어진 비밀번호가 충분히 길 경우에 해당 비밀번호를 암호화하여 반환하는 함수
- 너무 짧으면 logic_error 타입의 예외를 던지도록 만들어져있음 (항목 54 참조)

```cpp
// 이 함수는 "encrypted" 변수를 너무 일찍 정의해 버립니다.
std::string encryptPassword(const std::string& password)
{
    using namespace std;

    string encrypted;

    if (password.length() < MinimumPasswordLength) {
        throw logic_error("Password is too short");
    }

    ...  // 주어진 비밀번호를 암호화하여 encrypted
         // 변수에 넣는 데 필요한 일들을 여기서 합니다.

    return encrypted;
}

```

encrypted라는 std::string 객체가 함수 시작하자마자 생성됨.

if문에서 예외(throw)가 발생하면, 암호화 로직까지는 가지도 못하고 함수가 바로 종료됨.

⇒ encrypted 객체의 생성과 소멸에 대해 비용을 내야 한다는 이야기

```cpp
// 이 함수는 encrypted 변수가 진짜로 필요해질 때까지 정의를 미룹니다.
std::string encryptPassword(const std::string& password)
{
    using namespace std;

    if (password.length() < MinimumPasswordLength) {
        throw logic_error("Password is too short");
    }

    string encrypted;
												    // 주어진 비밀번호를 암호화하여 encrypted
														// 변수에 넣는 데 필요한 일들을 여기서 합니다.

    return encrypted;
}

```

⇒ encrypted 변수가 정의될 때 초기화 인자가 없음

상당수의 경우에 객체를 가지고 하는 가장 처음의 일은 ‘값을 주는 것’

⇒ 대개 대입 연산을 쓰게 됨

why? 하지만 이건 효율이 좋지 않다는 걸 항목 4에서 업급함

[항목 4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자 - 작성자: 권우현](https://www.notion.so/4-25ae4ff3b4168053bcd8d97e38172f32?pvs=21) 

```cpp
void encrypt(std::string& s);// 이 자리에서 s를 바로 암호화합니다.
```

```cpp
// 이 함수는 encrypted 변수가 필요해질 때까지 이 변수의 정의를
// 늦추긴 했지만, 여전히 쓸데없이 비효율적입니다.
std::string encryptPassword(const std::string& password)
{
    ...
    // 길이를 점검하는 부분은 똑같으므로 생략

    std::string encrypted;      // 기본 생성자에 의해 만들어지는 encrypted
    encrypted = password;       // encrypted에 password를 대입

    encrypt(encrypted);
    return encrypted;
}
```

```cpp
// 결국 여기까지 오다: encrypted를 정의하고 초기화하는 가장 좋은 방법
std::string encryptPassword(const std::string& password)
{
    ...
    // 길이를 점검합니다.

    std::string encrypted(password);  // 변수를 정의함과 동시에 초기화합니다.
                                      // 이때 복사 생성자가 쓰입니다.

    encrypt(encrypted);
    return encrypted;
}

=> 이렇게 하면 의미도 없고 비용도 만만치 않은 기본 생성자 호출을 건너뛰게됨!
=> '늦출 수 있는 데까지'의 진짜 뜻!!
```

- 변수를 사용해야 할 때가 오기 전까지 변수의 정의를 늦추기
- 초기화 인자를 손에 넣기 전까지 정의를 늦출 수 있는지

⇒ 쓰지도 않을 객체가 만들었다 없어지는 일이 생기지 않으며, 불필요한 기본 생성자 호출도 일어나지 않는다.

⇒ 덤으로, 누가 봐도 그 변수의 의미가 명확한 상황에서 초기화가 이루어 지기 때문에, 변수의 쓰임새를 문서화 하는 데도 큰 도움이 된다.

# 3. 루프의 예)

- 어떤 변수가 루프 안에서만 쓰이는 경우면,
    - 해당 변수를 루프 바깥에서 미리 정의해 놓고 루프안에서 대입?
    - 루프 안에 변수를 정의하는 방법?

```cpp
// A 방법: 루프 바깥쪽에 정의
Widget w;
for (int i=0; i<n; ++i){
	w = i 에 따라 달라지는 값;
	...
}
```

```cpp
// B 방법: 루프 안쪽에 정의
for (int i=0; i<n; ++i){
	Widget w(i에 따라 달라지는 값);
	...
}
```

| A 방법 | B 방법 |
| --- | --- |
| 생성자 1번 + 소멸자 1번 + 대입 n번 | 생성자 n 번 + 소멸자 n 번 |
- if Widget 클래스가 (대입에 들어가는 비용 < 생성자-소멸자 쌍) 이라면,
    - 일반적으로 A 방법이 훨씬 효율이 좋다.
    - 이 차이는 n 이 커질 때 특히 더 커짐.
- else
    - B 방법이 좋을것.