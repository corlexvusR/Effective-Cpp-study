# 항목 29: 예외 안전성이 확보되는 그날 위해 싸우고 또 싸우자! - 작성자: 서영은

<aside>
🔎

# 이것만은 잊지말자!

- 예외 안전성을 갖춘 함수는 실행 중 예외가 발생되더라도 자원을 누출시키지 않으며 자료구조를 더럽힌 채로 내버려 두지 않는다.
- 예외 안전성 보장은 `기본적인 보장, 강력한 보장, 예외 금지 보장`이 있다.
- 강력한 예외 안전성 보장은 `복사 후 맞바꾸기` 방법을 써서 구현할 수 있지만, 모든 함수에 대해 강력한 보장이 실용적인 것은 아니다.
- 어떤 함수가 제공하는 예외 안전성 보장의 강도는 그 함수가 내부적으로 호출하는 함수들이 제공하는 가장 약한 보장을 넘지 않는다.
</aside>

---

# 📌 예외 안전성(exception safety)이 없는 예

```cpp
class PrettyMenu {
public:
	...
	void changeBackground(std::istream& imgSrc); // 배경그림을 바꾸는 멤버 함수
	...
	
private:
	Mutex mutex;       // 이 객체 하나를 위한 뮤텍스
	
	Image *bgImage;    // 현재의 배경 그림
	int imageChanges;  // 배경그림이 바뀐 횟수

};
```

스레딩 환경에서 동작할 수 있도록 설계되었기 때문에, 병행성 제어를 위해 뮤텍스(mutex)를 갖고 있음.

```cpp
void PrettyMenu::changeBackground(std::istream& imgScr)
{
	lock(&mutex);                   // 뮤텍스 획득
	
	delete bgImage;                 // 이전의 배경그림을 없앰
	++imageChanges;                 // 그림 변경 횟수를 갱신
	bgImage = new Image(imgSrc);    // 새 배경그림을 깔기
	
	unlock(&mutex);                 // 뮤텍스 해제
}
```

## 예외 안전성을 확보하려면 맞춰야하는 두 가지 요구사항

- **자원이 새도록 만들지 않는다.**
    - new Image(imgSrc) 에서 예외를 던지면 unlock 함수가 실행되지 않아서 뮤텍스 해제가 안됨
- **자료구조가 더럽혀지는 것을 허용하지 않는다.**
    - new Image(imgSrc)가 예외를 던지면 bgImage가 가리키는 객체는 이미 삭제된 후.
    - 새 그림이 제대로 깔리지 않았는데도 imageChanges 변수는 이미 증가함

## ✅ 자원 누출 문제 해결 방법. RAII 클래스 사용

```cpp
void PrettyMenu::changeBackground(std::istream& imgScr)
{
	Lock m1(&mutex);                // Lock 클래스 생성자에서 뮤텍스 획득, 소멸자에서 해제.
	
	delete bgImage;                 // 이전의 배경그림을 없앰
	++imageChanges;                 // 그림 변경 횟수를 갱신
	bgImage = new Image(imgSrc);    // 새 배경그림을 깔기
}
```

- **RAII (Resource acquisition is initialization)**
    - 객체가 생성될 때 자원을 획득하고, 객체가 소멸할 때 자원을 해제하는 디자인 패턴

# 📌 예외 안전성을 갖춘 함수의 보장 세 가지

예외 안전성을 갖춘 함수는 아래의 세 가지 보장(guarantee) 중 하나를 제공함.

## **기본적인 보장 (basic guarantee)**

- 함수 동작 중에 예외가 발생하면 실행 중인 프로그램에 관련된 모든 것들을 유효한 상태로 유지하겠다는 보장.
- 어떤 객체나 자료구조도 더럽혀지지 않으며, 모든 객체의 상태는 내부적으로 일관성을 유지함.
- 즉, **모든 클래스 불변속성이 만족된 상태**
- 하지만 프로그램의 상태가 정확히 어떤가는 예측이 안 될 수도 있음
    - 예를 들어 changeBackground 함수가 동작하다가 예외가 발생했을 때
    - PrettyMenu 객체는 바로 이전의 배경그림을 그대로 그릴 수도 있고, 아니면 기본 배경그림을 사용할 수도 있음. 개발자가 아닌 사용자 쪽에서는 예측할 수 없음.

## **강력한 보장 (strong guarantee)**

- 함수 동작 중에 예외가 발생하면, 프로그램의 상태를 절대로 변경하지 않겠다는 보장.
- 이런 함수를 호출하는 것은 `원자적인(atomic)` 동작임.
- 호출이 성공하면(예외가 발생하지 않으면) 마무리까지 완벽하게 성공하고,
호출이 실패하면 함수 호출이 없었던 것처럼 프로그램의 상태가 되돌아감.
- 기본 보장 제공 함수보다 쓰기 쉬움
    - 예측할 수 있는 프로그램의 상태가 두 개이기 때문.
    - 함수가 성공적으로 실행을 마친 후의 상태, 함수가 호출될 때의 상태

## **예외불가 보장 (nothrow guarantee)**

- 예외를 절대로 던지지 않겠다는 보장.
- 약속한 동작은 언제나 끝까지 완수하는 함수라는 의미.
- 기본제공 타입(int, 포인터 등)에 대한 모든 연산은 예외불가 보장이 제공됨.

### 🤔 어떤 예외도 던지지 않게끔 예외 지정이 된 함수는 예외불가 보장을 제공하는 건가요??

- 아님. 예시를 보자.

```cpp
int doSomething() throw();    // 비어 있는 예외 지정
```

위 함수는 절대로 예외를 던지지 않겠다는 말이 아님.

만약 doSomething에서 예외가 발생되면 매우 심각한 에러가 생긴 것으로 판단되므로, 지정되지 않은 예외가 발생했을 경우에 실행되는 처리자인 unexpected 함수가 호출되어야 한다는 의미.

- **unexpected 함수란?** 기본적으로 terminate 함수 호출함 (프로그램 강제 종료)
    
    https://learn.microsoft.com/ko-kr/cpp/c-runtime-library/reference/unexpected-crt?view=msvc-170
    
    https://learn.microsoft.com/ko-kr/cpp/c-runtime-library/exception-handling-routines?view=msvc-170
    
    https://learn.microsoft.com/ko-kr/cpp/cpp/noexcept-cpp?view=msvc-170
    
    https://learn.microsoft.com/ko-kr/cpp/cpp/exception-specifications-throw-cpp?view=msvc-170
    

사실 doSomething은 어떤 예외 안전성 보장도 제공하지 않을 수도 있음.

함수 선언문에는 해당 함수가 맞는지, 이식성이 있는지, 효율적인지, 예외 안전성 보장을 제공하는지도 알려주지 않음.

`구현` 이 결정하는 것임.

# ✅ 어떤 보장을 제공할지 선택하자

예외 안전성의 관점에서 보면 예외불가 보장이 가장 훌륭하겠지만, 예외를 던지는 함수를 호출하지 않고 C++의 C 부분으로부터 벗어나오기는 힘듦.

동적 할당 메모리를 사용하는 STL 컨테이너 쪽만 봐도, 요청에 맞는 메모리를 확보할 수 없으면 bad_alloc 예외를 던지도록 구현되어 있음 (항목 49 참조)

**현실적으로는 대부분의 함수에 있어서 기본적인 보장과 강력한 보장 중 하나를 고르게 됨**

# 📌 강력한 보장

예외 안전성 보장 중에는 강력한 보장이 가장 좋음. **실용성이 확보되는 경우라면 반드시 제공**해야 함.

그러나 언제나 실용적인 것은 아님.

```cpp
class PrettyMenu
{
	...
	std::tr1::shared_ptr<Image> bgImage;
	...
};

void PrettyMenu:::changeBackground(std::istream& imgSrc)
{
	Lock m1(&mutex);
	bgImage.reset(new Image(imgSrc));  // bgImage의 내부 포인터를 
	                                   // new Image 표현식의 실행 결과로 바꿔치기
	++imageChanges;
}
```

- PrettyMenu의 bgImage 데이터 멤버의 타입을 Image*에서 자원관리 전담용 포인터로 바꿈
- 배경그림이 진짜로 바뀌기 전에는 imageChanges를 증가시키지 않음

tr1::shared_ptr::reset 함수가 호출되려면 new Image(imgSrc)가 제대로 생성되어야 함.

- **shared_ptr::reset 함수란?** 소유하는 리소스를 인자로 변경.
    
    참고 https://learn.microsoft.com/ko-kr/cpp/standard-library/shared-ptr-class?view=msvc-170
    

### ⚠️ 매개변수 imgSrc의 문제점

Image 클래스의 생성자가 실행되다가 예외 발생시, 그 시점에 입력 스트림의 읽기 표시자가 이동한 채로 남아있을 가능성이 있음.

이 표시자의 이동이 전체 프로그램의 나머지에 영향을 미칠 수 있는 어떤 변화로 작용할 수도 있음.

- **입력 스트림과 스트림 버퍼에 대한 참고 자료**
    
    https://modoocode.com/213
    

### ✅ 해결 방법

매개변수 타입으로 istream을 쓰지 않고 배경그림 파일의 이름을 나타내는 타입 같은 것으로 바꿔보자.

## 📌 복사 후 맞바꾸기 (copy-and-swap)

어떤 객체를 수정하고 싶을 때, 그 객체의 사본을 만들어 놓고 그 사본을 수정하는 것.

이러면 수정 동작 중에 실행되는 연산에서 예외가 던져져도 원본 객체는 바뀌지 않은 채로 남음.

필요한 동작이 전부 성공적으로 완료되고 나면 수정된 객체를 원본 객체와 맞바꿈.

이때, 이 작업을 예외를 던지지 않는 연산 내부에서 수행함.

### ❓구현 방법

`pimpl 관용구` (항목 31에 자세히)

진짜 객체의 모든 데이터를 별도의 구현(implementation) 객체에 넣어두고, 그 구현 객체를 가리키는 포인터를 진짜 객체가 물고 있게 함.

```cpp
struct PMImpl {
	std::tr1::shared_ptr<Image> bgImage;
	int imageChanges;
};

class PrettyMenu {
	...
private:
	Mutex mutex;
	std::tr1::shared_ptr<PMImpl> pImpl;
};

void PrettyMenu::changeBackground(std::istream& imgSrc)
{
	using std::swap;
	Lock m1(&mutex); // 뮤텍스 획득
	
	std::tr1::shared_ptr<PMImpl> pNew(new PMImpl(*pImpl)); // 객체의 데이터 부분 복사
	pNew->bgImage.reset(new Image(imgSrc));                // 사본 수정
	++pNew->imageChanges;
	
	swap(pImpl, pNew);      // 새 데이터로 바꿔 넣어 진짜로 배경그림 바꿈
	
} // 뮤텍스 해제
```

**🤔 PMImpl이 클래스가 아니라 구조체인 이유는 뭔가요?**

PrettyMenu 클래스에서 pImpl이 private이라 구현 객체의 데이터가 바로 캡슐화되기 때문에 편하게 쓰려고 구조체로 한 것. 클래스로 해도 상관 없음.

복사 후 맞바꾸기 전략은 객체의 상태를 `전부 바꾸거나 혹은 안 바꾸거나(all-or-nothing)` 방식으로 유지하려는 경우에 아주 좋음.

### ❗함수 전체가 강력한 예외 안전성을 갖도록 보장하지는 않는다

changeBackground 함수의 전체 흐름을 추상해 놓은 someFunc()을 보자.

복사 후 맞바꾸기 수법을 쓰되, f1 및 f2라는 다른 함수의 호출문이 들어있는 형태임.

```cpp
void someFunc()
{
	...     // 이 함수의 현재 상태에 대해 사본을 만들어 놓기
	f1();
	f2();
	...     // 변경된 상태를 바꾸어 넣기
}
```

f1 혹은 f2에서 보장하는 예외 안전성이 강력하지 않으면, 위의 구조로는 someFunc 함수가 강력한 예외 안전성을 보장하기 힘듦.

예를 들어 f1이 기본적인 보장만 제공한다고 가정.

someFunc 함수에서 강력한 보장을 제공하려면,

1. f1을 호출하기 전에 프로그램 전체의 상태를 결정하고
2. f1에서 발생하는 모든 예외를 잡아낸 후에
3. 원래의 상태로 되돌리는 코드를 작성해야 함

**🤔 f1 및 f2 둘 다 강력한 예외 안전성을 보장하면 괜찮나요?**

아님.

예를 들어 f1이 끝까지 실행되고 나면 프로그램 상태는 f1에 의해 어떻게든 변해 있을 것.

그 다음에 f2가 실행되다가 예외를 던지면 그 프로그램의 상태는 someFunc가 호출될 때의 상태와 아예 달라져 있을 것.

f2에서 아무것도 바꾸지 않았더라도.

## ⚠️ 강력한 보장의 문제점

### 함수의 부수효과(side effect) 문제

자기 자신에만 국한된 것들의 상태를 바꾸며 동작하는 함수의 경우에는 강력한 보장을 제공하기가 비교적 수월함.

비지역 데이터에 대해 부수효과를 주는 함수는 이렇게 하기 매우 까다로움.

예를 들어 f1을 호출하고 나서 생기는 부수효과로 데이터베이스가 변경됨.

someFunc 쪽에서는 어떻게 손 쓸 수 없음.

특이한 경우가 아닌 이상, 이미 확정(commit) 된 데이터베이스 변경사항을 되돌릴 수 있는 방법은 없음.

그 데이터베이스의 다른 사용자가 변경사항을 이미 봤을 수 있음.

### 효율 문제

복사 후 맞바꾸기는 객체의 데이터에 대해 사본을 만들어 놓고 사본을 변경한 후에, 사본과 원본의 바꿔치기 작업을 예외를 던지지 않는 함수 내부에서 하는 것.

따라서, 수정하고 싶은 객체를 복사할 공간과 복사에 걸리는 시간을 감수해야 함.

# 📌 예외 안전성은 있거나 아예 없거나 둘 중 하나다

someFunc을 예로 들어 보자.

f2가 예외 안전성 보장을 전혀 제공하지 않는다고 가정함.

f2에서 예외가 터지면 f2 안에서 자원이 누출될 수 있음.

f2 때문에 프로그램의 자료구조가 망가질 수 있음. 

정렬되어 있던 배열이 헝클어질지도 모르고 어떤 자료구조에서 다른 자료구조로 전송되던 객체가 날아가 버릴지도 모름.

이런 문제가 터져도 someFunc 차원에선 손 쓸 방법이 없음.

일부만 예외 안전성을 갖춘 시스템은 없음.

소프트웨어 시스템은 예외에 안전하거나 예외에 뚫려 있거나 둘 중 하나임.

예외 안전성이 없는 함수가 하나라도 쓰이고 있으면 그 시스템은 전부가 예외에 안전하지 않은 시스템임.