# 항목 27 : 캐스팅은 절약, 또 절약! 잊지 말자 - 작성자 : 신동욱

### 결론

- 캐스팅을 피하자
- 피할 수 없다면 구형 스타일 캐스팅보다 C++ 스타일 캐스팅을 선호하자

### 들어가며….

- C++은 “어떤 일이 있어도 타입 에러가 발생하지 안도록 보장한다.”는 철학이 있음
- 근데 캐스트(cast)라고 있는데 이놈이 저 철학을 다 깰 수 있음
- 그래서 캐스팅은 조심히 써야 하는 기능임

## 캐스팅이 뭔데?

- 아 타입 캐스팅이라고 하면 이해가 쉬울라나
- 예를 들어 double 타입의 변수를 int 타입으로 바꿔서 쓰는거죠

```cpp
double d = 3.14;
int i = (int)d; // d를 int로 캐스팅
```

## 캐스팅 방법 세 가지

### 1. C 스타일 캐스트
    
```cpp
(T) 표현식 //표현식 부분을 T 타입으로 캐스팅

ex) 
double valid = 3.14;
int x = (int)valid;
```
    
### 2. 함수 방식 캐스트
    
```cpp
T(표현식) //표현식 부분을 T 타입으로 캐스팅

ex)
double valid = 3.14;
int x = int(valid);
```

- 이렇게 캐스팅하는건 결과는 똑같음. 이 두 가지 형태를 “구형 스타일 캐스트”라고 부르겠다네요
    
### 3. 신형 스타일의 캐스트 or C++ 스타일 캐스트

<p>
<img src = "image1.png" width=70%>
</p>


#### 1. const_cast
    
```cpp
T* p2 = const_cast<T*>(p1);
```
    
- `p1`이 `const T*`이면 `p2`는 `T*`가 됨
- 즉, 포인터나 참조의 `const` 속성을 제거하는데 사용
- 사용 예시
    
    ```cpp
    void f(char* str) {
        // str을 수정할 수도 있는 함수
    }
    
    void g(const char* cstr) {
        // const char*을 받았는데 f()는 char*만 받음
        f(const_cast<char*>(cstr));  // const_cast로 const 제거
    }
    
    ```
        
- 주의! → ㄹㅇ const로 선언된 객체의 값을 바꾸려고 하면 UB임

---

#### 2. dynamic_cast
- 안전한 다운캐스팅을 할 때 사용하는 연산자

```cpp
Derived* dptr = dynamic_cast<Derived*>(base_ptr);
```

- `base_ptr`이 실제로 `Derived`를 가리키고 있다면 `dptr`이 그 주소가 되고,
- 아니라면 `dptr`은 `nullptr`이 됨
- 언제 쓰냐?
- 업캐스팅(파생 → base)는 항상 안전하므로 `static_cast`나 암시적 변환(컴파일러가 알아서 하는거)을 사용해도 됨
- 다운캐스팅(조상 → 자식)은 런타임에 실제 객체가 파생인지 확인해야 안전

```cpp
class Base { public: virtual ~Base() {} };
class Derived : public Base {};

Base* b1 = new Derived;
Base* b2 = new Base;

Derived* d1 = dynamic_cast<Derived*>(b1); // OK, d1 != nullptr
Derived* d2 = dynamic_cast<Derived*>(b2); // 실패, d2 == nullptr
```

- 아니 근데 개뽝치게 Base* 형 포인터로 왜 다른걸 가리키는 코드를 만드냐고오
- C++에서 상속과 가상 함수를 사용하면 “부모 타입 포인터/참조로 자식 객체를 다룰 수 있다”는 게 핵심임
- 즉, **공통 인터페이스(Base)로 다양한 하위 클래스 객체들을 같은 컨테이너에 넣어서 다루거나, 공통된 API로 호출하려는 상황이 많아용**
    
    ```cpp
    std::vector<Base*> objects;
    objects.push_back(new Derived);
    objects.push_back(new Base);
    
    for (Base* obj : objects) {
        obj->hello(); // 각 객체의 실제 타입에 맞게 동작
    }
    ```
    
- 이 포인터가 ㄹㅇ Derived임?을 알아야 할 때가 있잖슴
    
    ```cpp
    for (Base* obj : objects) {
        if (Derived* d = dynamic_cast<Derived*>(obj)) {
            // obj가 Derived라면 d 사용
        }
    }
    ```

---
            
#### 3. ~~reinterpret_cast ←이거 거의 안써요(Chatgpt)~~

---

#### 4. static_cast
- C++에서 가장 자주 쓰이는 캐스팅 (feat.gpt)
- 컴파일 시점에 타입을 바꾸는, 비교적 안전한 변환을 할 때 사용

```cpp
T new_value = static_cast<T>(expr);
```

- 이렇게 쓰면 `expr` 을 컴파일 타임에 `T`타입으로 변환함
- 런타임 체크는 안 하고, 컴파일러가 “이 변환이 논리적으로 가능하다”고 판단

```cpp
class Base {};
class Derived : public Base {};

Derived d;
Base* b = static_cast<Base*>(&d);   // Derived* → Base* (업캐스팅)

Derived* dp = static_cast<Derived*>(b); // Base* → Derived* (다운캐스팅, 런타임 체크 없음)
```

- 다운캐스팅이 안전한지는 개발자가 보장해야 함
- 런타임에 타입을 확인하고 싶으면 `dynamic_cast`를 써야 함
- 그래서 이게 뭐라고? 정적 캐스팅 → 캐스팅이 “논리적으로 가능한건가?”를 보장하도록
- 런타임에 UB(정의되지 않은 동작) 발생은 몰라용

### 신형 스타일 캐스트를 써야 하는 이유

- 코드를 읽을 때 알아보기 쉽다 → 소스 코드의 어디에서 C++의 타입 시스템이 망가졌는지를 찾아보는 작업이 편해진다
- 캐스트를 사용한 목적을 더 좁혀서 지정하기 때문에 컴파일러 쪽에서 사용 에러를 진단할 수 있다

### 잘못된 캐스팅 예제

```cpp
class Window {
public:
    virtual void onResize();
};

class SpecialWindow : public Window {
public:
    virtual void onResize() {
        static_cast<Window>(*this).onResize();
        // … SpecialWindow 고유 처리
    }
};
```