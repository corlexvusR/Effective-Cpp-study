# 항목 50: new 및 delete를 언제 바꿔야 좋은 소리를 들을지를 파악해 두자 - 작성자: 서영은

<aside>

# 🔎 이것만은 잊지말자!

- 사용자 정의 new 및 delete를 작성하는 데는 여러 가지 이유가 있다.
- 수행 성능 향상, 힙 사용 시 에러 디버깅, 힙 사용 정보 수집 등
</aside>

---

# new와 delete를 바꾸고 싶은 가장 흔한 이유 세 가지

## **잘못된 힙 사용 탐지**

- new한 메모리를 delete 하지 않으면 메모리 누수 생김
- new한 메모리를 두 번 이상 delete하면 미정의 동작 발생 (어떤 일이 날지 모름)
  - 할당된 메모리 주소의 목록을 operator new가 유지해 두고 operator delete가 그 목록으로부터 주소를 하나씩 제거해 주게 만들어져 있다면 위 실수 잡기 좋을 것
- 데이터 오버런 및 언더런 발생 가능
  - `데이터 오버런(overrun)`: 할당된 메모리 블록의 끝을 넘어 뒤에 기록하는 것
  - `언더런(underrun)` : 할당된 메모리 블록의 시작을 넘어 앞에 기록하는 것
- 이런 경우에 대비하여 사용자 정의 operator new를 활용한다면, 요구된 크기보다 약간 더 메모리를 할당한 후에 사용자가 실제로 사용할 메모리의 앞과 뒤에 오버런/언더런 탐지용 바이트 패턴(경계 표지(signature)를 적어두도록 만들 수 있음
- operator delete는 누군가 이 경계표지에 손을 댔는지 안 댔는지 점검하도록 만듦.
  만일 경계표지 부분에 원래와 다른 정보가 적혀 있다면 할당된 메모리 블록을 사용하는 도중에 오버런이나 언더런이 발생한것이므로, operator delete는 이 사실을 로그로 기록함으로써 문제를 일으킨 포인터 값을 남겨 놓을 수 있음.

## **효율 향상**

- 컴파일러가 제공하는 기본 버전의 new와 delete는 대체적으로 일반적인 쓰임새에 맞추어 설계됨.
- **일반적인 쓰임새**
  - 실행 시간이 짧지 않은 프로그램(웹서버 등)에서 잘 돌아가야 하며, 1초 안에 끝나는 프로그램에서도 별 문제가 없어야 함.
  - 큰 블록만 할당하든 작은 블록만 할당하든, 아니면 크고 작은 블록이 섞여서 할당되든 간에 계속되는 메모리 할당 요청을 무난하게 처리해야 함
  - 프로그램 실행 내내 사용하는 블록 몇 개를 동적 할당하는 작업부터 수명이 짧은 객체를 아주 맣이 할당했다가 해제했다가 하는 작업까지, 여러가지 할당 유형도 소화할 수 있어야 함.
- **`힙 단편화(fragmentation)`**에 대한 대처방안도 있어야 함
  - 메모리 단편화란?? **메모리의 공간이 작은 조각으로 나뉘어져 사용 가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태**
    https://velog.io/@hanhs4544/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94Memory-Fragmentation
- **요약**
  - 개발자가 자기 프로그램이 동적 메모리를 어떤 성향으로 사용하는지 제대로 이해하고 있다면 사용자 정의 new, delete를 사용하는게 더 좋은 성능을 낼 수 있음
  - 좋은 성능 ⇒ 실행 속도가 빠르고, 메모리도 적게 차지함

## **동적 할당 메모리의 실제 사용에 관한 통계 정보 수집**

- 소프트웨어가 동적 메모리를 어떻게 사용하는지에 관한 정보 수집
- 할당된 메모리 블록의 크기는 어떤 분포를 보이는지
- 각각의 사용 기간은 어떤 분포를 보이는지
- 메모리가 할당되고 해제되는 순서가 FIFO(선입선출, first in first out)인지, LIFO(후입선출, last in first out)인지
- 시간 경과에 따라 사용 패턴이 바뀌는지
- 각 실행 단계마다 소프트웨어가 보이는 메모리 할당/해제 패턴이 확연한 차이가 있는지
- 한 번에 실제로 쓰이는 동적 할당 메모리의 최대량(최고수위선 high water mark)은 어떤지

# 사용자 정의 operator new 개념

버퍼 오버런 및 언더런을 탐지하기 쉬운 형태로 만들어주는 operator new

```cpp
static const int signature = 0xDEADBEEF;
typedef unsigned char Byte;

// 고칠 부분이 있는 코드
void* operator new(std::size_t size) throw(std::bad_alloc)
{
	using namespace std;
	size_t realSize = size + 2 * sizeof(int); // 경계표지 2개를 앞뒤에 붙일 수 있을만큼 늘림
	void *pMem = malloc(realSize);           // malloc을 호출하여 실제 메모리를 얻어냄
	if(!pMem) throw bad_alloc();

	// 메모리 블록의 시작 및 끝부분에 경계표지를 기록
	*(static_cast<int*>(pMem)) = signature;
	*(reinterpret_cast<int*>(static_cast<Byte*>(pMem) + realSize 	- sizeof(int))) =
	signature;

	// 앞쪽 경계표지 바로 다음의 메모리를 가리키는 포인터 반환
	return static_cast<Byte*>(pMem) + sizeof(int);
}
```

operator new를 만들 때 통상적으로 쓰이는 관례를 지키지 않음

- new 처리자 함수를 호출하는 루프가 반드시 들어있어야 함 (항목 51에서 자세히)

## 바이트 정렬(alignment) \*\*\*\*문제

컴퓨터는 아키텍처적으로 특정 타입의 데이터가 특정 종류의 메모리 주소를 시작 주소로 하여 저장될 것을 요구사항으로 가짐

- 예) 포인터는 4의 배수에 해당하는 주소에 맞춰 저장 (4바이트 단위로 정렬)
- double 값은 8의 배수에 해당하는 주소에 맞춰 저장 (8바이트 단위로 정렬)

바이트 정렬 제약을 따르지 않으면 하드웨어 예외를 일으킬 수 있음

- 느슨한 제약을 두는 아키텍처도 있음 ⇒ 이런 경우 바이트 정렬 만족시 더 나은 성능 제공
  - 예) 인텔 x86 아키텍처. 어떤 바이트 단위에 맞추더라도 double 값을 정렬할 수 있지만 8바이트 단위로 정렬하면 런타임 접근 속도가 훨씬 빨라짐

모든 operator new 함수는 어떤 데이터 타입에도 바이트 정렬을 적절히 만족하는 포인터를 반환해야 함

- 표준 malloc 함수는 이 요구사항에 맞춰 구현되어 있어서 malloc에서 얻은 포인터를 operator new가 바로 반환하는 것은 안전함
- 하지만 위 예시 함수에서는 malloc에서 나온 포인터를 반환하지 않음.
- 그 포인터를 기준으로 int 크기만큼 뒤로 어긋난 주소를 포인터로 반환하고 있음.
- 이러면 안전하다는 보장이 없음.
- 만일 operator new를 호출해서 double을 담을 메모리를 얻었는데, int의 크기가 4바이트지만 double이 8바이트 단위로 정렬되어야 하는 컴퓨터에서 프로그램이 실행되고 있다면 바이트 정렬이 완전히 어긋나버린 포인터가 operator new에서 반환될 것
- 이것 때문에 어떤 경우는 프로그램이 다운되거나 실행 속도가 느려지는 수준으로 끝날수도

## 해결 방법

- **일반적인 경우, 꼭 만들어 쓸 이유가 없다면 굳이 만들지 말자**
  - 바이트 정렬 등의 세세한 문제를 어떻게 다루냐에 따라 메모리 관리자가 달라짐.
  - 잘 돌아가는 사용자 정의 메모리 관리자를 만들기는 어려움.
  - 시중에 있는 컴파일러 중에는 메모리 관리 함수에 디버깅 및 로깅 기능을 넣어 놓고 필요에 따라 전환할 수 있도록 해둔 것들도 있음.
  - ⇒ 컴파일러 문서를 읽어보자
- 메모리 관리 함수만을 전문적으로 다루는 **상업용 제품 사용**
- **오픈 소스**
  - 부스트(항목 55 참조)의 풀(Pool) 라이브러리
  - 메모리 할당자가 크기가 작은 객체(소형 객체)를 많이 할당할 경우에 맞춰 튜닝되어 있음

# 사용자 정의 new 및 delete가 의미있는 경우

- **잘못된 힙 사용 탐지**
- **동적 할당 메모리의 실제 사용에 관한 통계 정보 수집**
- **할당 및 해제 속력 향상**
  - 기본 제공되는 범용 할당자는 사용자 정의 버전보다 느린 경우가 종종 있음
  - 특히 사용자 정의 버전이 특정 타입의 객체에 맞춰 설계되어 있으면 더욱 그러함
  - 부스트의 Pool 라이브러리에서 제공하는 할당자처럼 고정된 크기의 객체만 만들어주는 할당자의 전형적인 응용 예시가 바로 클래스 전용(class-specific) 할당자
  - 응용프로그램이 단일 스레드로 동작하는데 컴파일러의 메모리 관리 루틴이 다중 스레드에 맞춰져 있다면, 스레드 안전성이 없는 할당자를 직접 만들어씀으로써 속력 이득을 볼 수 있음
  - 단, 적절한 프로파일링을 통해 프로그램 안에서 진짜로 병목을 일으키는 원인인지 확인해야 함
- **기본 메모리 관리자의 공간 오버헤드 줄이기**
  - 범용 메모리 관리자는 메모리도 많이 먹는 경우가 있음
  - 할당된 각각의 메모리 블록에 대해 전체적으로 지우는 부담이 꽤 되기 때문
  - 크기가 작은 객체에 대해 튜닝된 할당자를 사용하면 이런 오버헤드를 제거할 수 있음
- **적당히 타협한 기본 할당자의 바이트 정렬 동작 보장**
  - x86 아키텍처에서는 double이 8바이트 단위로 정렬되어 있을 때 읽기/쓰기 속도가 가장 빠름
  - 기본제공 operator new 함수가 double에 대한 동적 할당 시에 8바이트 정렬을 보장하지 않는다면, 사용자 정의 버전으로 바꿈으로써 수행 성능을 높일 수 있음
- **임의의 관계를 맺고 있는 객체들을 한 군데에 나란히 모으기 위해**
  - 한 프로그램에서 특정 자료구조 몇 개가 대개 한 번에 동시에 쓰이고 있다는 사실을 알고 있고, 앞으로 이들에 대해 페이지 부재(page fault) 발생 횟수를 최소화하고 싶을 경우
  - 해당 자료구조를 담을 별도의 힙을 생성함으로써 이들이 최대한 적은 페이지를 차지하도록 하면 효과를 볼 수 있음
  - 이러한 메모리 군집화는 위치 지정(placement) new 및 위치지정 delete를 통해 구현 가능
- **원하는 동작 수행**
  - 메모리 할당과 해체를 공유 메모리에 하고 싶은데, 공유 메모리 조작은 C API로밖에 할 수 없을 때
    - 위치지정 new와 위치지정 delete를 사용
  - 응용프로그램 데이터의 보안 강화를 위해 해제한 메모리 블록에 0을 덮어 쓰는 사용자 정의 operator delete
